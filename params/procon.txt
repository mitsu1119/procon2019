/include/agent.hpp
 
#pragma once

#include "field.hpp"
#include "useful.hpp"

class Agent {
private:
	struct {
		// x座標, y座標
		// 0 <= x, y < 20 
		uint_fast32_t x: 5;
		uint_fast32_t y: 5;

		// 属性。Panelの属性のMINE_ATTRとENEMY_ATTRをそのまま使う
		uint_fast32_t attr: 2;

		// 次に移動する座標
		uint_fast32_t nextX: 5;
		uint_fast32_t nextY: 5;

		// 次に移動する座標のバッファ(全探索用)
		uint_fast32_t nextbufX: 5;
		uint_fast32_t nextbufY: 5;
		
	};
	
	uint_fast32_t agent_id;

public:
	Agent();
	Agent(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr);
	Agent(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr, uint_fast32_t id);

	void move(Direction direction);

	uint_fast32_t getX();
	uint_fast32_t getY();
	uint_fast32_t getnextX();
	uint_fast32_t getnextY();
	void setnextbufXY(uint_fast32_t nextbufX, uint_fast32_t nextbufY);
	uint_fast32_t getnextbufX() const;
	uint_fast32_t getnextbufY() const;
	uint_fast32_t getAttr();

	uint_fast32_t getID();

	// (nextX, nextY)を(x, y)に適用する
	void setNext();
	void reverseAttr();
};

/include/ai.hpp
#pragma once

#include "agent.hpp"
#include "field.hpp"
#include "useful.hpp"

class Agent;
class Field;

class AI{
private:
public:

	const std::vector<int> vec_x = { 0, 1, 1, 1, 0,-1,-1, -1, 0};
	const std::vector<int> vec_y = {-1,-1, 0, 1, 1, 1, 0, -1, 0};

public:

	AI();
	~AI();

	virtual	void init(const Field* field) = 0;
	virtual	void init(const Field& field) = 0;
	virtual void move(Field *field, const uint_fast32_t attr) = 0;

	const Direction changeDirection(const std::pair<uint_fast32_t, uint_fast32_t>& now, const std::pair<uint_fast32_t, uint_fast32_t>& next) const;
	int_fast32_t nextScore(Field field, const uint_fast32_t agent, const Direction direction) const;
	static const bool MineComp(std::pair<Field, Field>& lhs, std::pair<Field, Field>& rhs);
	static const bool EnemyComp(std::pair<Field, Field>& lhs, std::pair<Field, Field>& rhs);

};

inline const Direction AI::changeDirection(const std::pair<uint_fast32_t, uint_fast32_t>& now, const std::pair<uint_fast32_t, uint_fast32_t>& next) const{
	int dx = next.first - now.first;
	int dy = next.second - now.second;
	return xyToDirection(next.first - now.first, next.second - now.second);
}

class Random : public AI{
private:

	XorOshiro128p random;

public:

	Random();
	~Random();

	void init(const Field* field) override;
	void init(const Field& field) override;
	void move(Field *field, const uint_fast32_t attr) override;

};

class Greedy : public AI{
private:

	XorOshiro128p random;

public:

	Greedy();
	~Greedy();

	void init(const Field* field) override;
	void init(const Field& field) override;

	void singleMove(Field& field, const uint_fast32_t agent);
	void randomMove(Field& field, const uint_fast32_t agent, const uint_fast32_t x, const uint_fast32_t y);

	void move(Field *field, const uint_fast32_t attr) override;

};

constexpr uint_fast32_t beam_depth = 3;
constexpr uint_fast32_t beam_width = 3;

class BeamSearch : public AI{
private:

	Greedy greedy;
	Field search(Field *field, const uint_fast32_t agent, uint_fast32_t depth);
	
public:

	BeamSearch();
	~BeamSearch();

	void init(const Field* field) override;
	void init(const Field& field) override;

	void singleMove(Field& field, const uint_fast32_t agent);
	void move(Field* field, const uint_fast32_t attr) override;

};

constexpr uint_fast32_t bfs_depth = 3;

class BreadthForceSearch : public AI{
private:

	Greedy greedy;
	Field search(Field* field, const uint_fast32_t agent, uint_fast32_t depth);

public:

	BreadthForceSearch();
	~BreadthForceSearch();

	void init(const Field* field) override;
	void init(const Field& field) override;

	void singleMove(Field& field, const uint_fast32_t agent);
	void move(Field* field, const uint_fast32_t attr) override;

};

constexpr double_t move_weight                = 2;
constexpr double_t state_weight               = 55;
constexpr double_t heuristic_weight           = 5;
constexpr double_t value_weight               = 35;
constexpr double_t is_on_decided_route_weight = 80;

constexpr double_t is_on_mine_panel_weight    = 95;
constexpr double_t is_on_enemy_panel_weight   = 90;

constexpr double_t adjacent_agent_weight      = 10;
constexpr double_t average_distance_weght     = 40;

/*
static double_t move_weight;
static double_t state_weight;
static double_t heuristic_weight;
static double_t value_weight;
static double_t is_on_decided_route_weight;
static double_t is_on_mine_panel_weight;
static double_t adjacent_agent_weight;
static double_t average_distance_weght;
*/

class Node{
public:

	enum Status{
		NONE,
		OPEN,
		CLOSED
	};

	//------ 評価値 ------
	
	//ステータス
	Status status;
	//移動コスト
	int_fast32_t move_cost;
	//盤の状態によるコスト
	int_fast32_t state_cost;
	//ヒューリスティックコスト（推定コスト）
	int_fast32_t heuristic;
	//その地点での点数
	int_fast32_t  value;
	//確定ルートにかぶっているか？
  int_fast32_t is_on_decided_route;

	
	int_fast32_t is_on_mine_panel;
	int_fast32_t is_on_enemy_panel;

	
	//Agent同士が隣接しているかどうか
	int_fast32_t adjacent_agent;
	//Agent同士の平均距離
	double average_distance;

	
	//------ 探索で使用 ------
	
	uint_fast32_t move_num;
	Node* parent;
	std::pair<uint_fast32_t, uint_fast32_t> coord;

public:

	Node();
	~Node();
	const double getScore() const;

};

inline const double Node::getScore() const{
	return (this->move_cost * move_weight) + (this->state_cost * state_weight) + (this->heuristic * heuristic_weight) + (this->is_on_decided_route * is_on_decided_route_weight) - (this->value * value_weight) + (this->is_on_mine_panel * is_on_mine_panel_weight) + (this->adjacent_agent * adjacent_agent_weight) - (this->average_distance * average_distance_weght) - (this->is_on_enemy_panel * is_on_enemy_panel_weight);
}

constexpr uint_fast32_t simple_beam_depth = 3;
constexpr uint_fast32_t simple_beam_width = 3;
constexpr uint_fast32_t simple_bfs_depth  = 3;

class SimpleMove : public AI{
private:

	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> next_coord;

private:

	Field beamSearch(Field* field, const uint_fast32_t agent, uint_fast32_t depth) const;
	Field breadthForceSearch(Field* field, const uint_fast32_t agent, uint_fast32_t depth) const;

public:

	SimpleMove();
	~SimpleMove();
	
	void greedyMove(Field& field, const uint_fast32_t agent, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& decided_coord);
	void greedySingleMove(Field& field, const uint_fast32_t agent, const uint_fast32_t attr, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& decided_coord);
	void greedyMove(Field& field, const uint_fast32_t agent);
	void greedySingleMove(Field& field, const uint_fast32_t agent, const uint_fast32_t attr);
	const Direction greedySingleMove(Field& field, const uint_fast32_t agent, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& expect_coord) const;
	
	const Direction beamSearchSingleMove(Field field, const uint_fast32_t agent) const;
	void beamSearchMove(Field& field, const uint_fast32_t attr) const;

	const Direction breadthForceSearchSingleMove(Field& field, const uint_fast32_t agent) const;
	void breadthForceSearchSearchMove(Field& field, const uint_fast32_t attr) const;
	
	void init(const Field* field) override;
	void init(const Field& field) override;
	void move(Field* field, const uint_fast32_t attr) override;
	
};

constexpr uint_fast32_t greedy_count       = 8;
constexpr uint_fast32_t search_count       = 16;
constexpr uint_fast32_t astar_depth        = 10;

constexpr double_t occpancy_weight         = 50;
constexpr double_t is_on_decided_weight    = 20;
constexpr double_t is_angle_weight         = 2;
constexpr double_t is_side_weight          = 2;
constexpr double_t is_inside_closed_weight = 10;

constexpr uint_fast32_t max_mine_distance  = 20;
constexpr uint_fast32_t min_mine_distance  = 2;
constexpr uint_fast32_t min_agent_distance = 2;
constexpr uint_fast32_t min_goal_distance  = 2;
constexpr uint_fast32_t max_move           = 30;
constexpr uint_fast32_t min_move_cost      = 2;
constexpr int_fast32_t  min_value          = 10;

constexpr double_t score_weight            = 1.1;
constexpr double_t goal_weight             = 8;
constexpr double_t cost_weight             = 0.023;
constexpr int_fast32_t min_open_list_value = 8;
	
constexpr uint_fast32_t search_time        = 30000;
constexpr uint_fast32_t grace_time         = 2000;

/*
static uint_fast32_t greedy_count;
static uint_fast32_t search_count;
static uint_fast32_t astar_depth;

static double_t occpancy_weight;
static double_t is_on_decided_weight;
static double_t is_angle_weight;
static double_t is_side_weight;
static double_t is_inside_closed_weight;

static uint_fast32_t max_mine_distance;
static uint_fast32_t min_mine_distance;
static uint_fast32_t min_agent_distance;
static uint_fast32_t min_goal_distance;
static uint_fast32_t max_move;
static uint_fast32_t min_move_cost;
static int_fast32_t  min_value;

static double_t score_weight;;
static double_t goal_weight;
static double_t cost_weight;
static int_fast32_t min_open_list_value;

static uint_fast32_t search_time;
static uint_fast32_t grace_time;
*/

#define ANGLE_COORD 1
#define SIDE_COORD  2

class Astar : public AI{
private:
	
	friend SimpleMove;
	int_fast32_t average_score;

	//探索法
	Random random;
	BeamSearch beam_search;
	BreadthForceSearch breadth_force_search;
	Greedy greedy;
	SimpleMove simple_move;

private:

	//探索かけるたびにクリアする
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> search_target;
	std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>> decided_route;
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> decided_goal;
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> decided_coord;
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> next_coord;
	std::vector<int_fast32_t> current_score;


	//マルチスレッド用
	std::pair<uint_fast32_t, uint_fast32_t> tentative_goal;
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> tentative_route;
	int_fast32_t tentative_max_score;

	
	//カウンター
	std::vector<uint_fast32_t> counter;

	
	//時間管理
	std::chrono::system_clock::time_point clock;
	bool is_time_over;

	
private:

	//移動
	void greedyMove(Field& field, const uint_fast32_t agent, const uint_fast32_t move_num);
	void decidedMove(Field& field, const uint_fast32_t agent, std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>>& route);
	Direction exceptionMove(Field& field, const uint_fast32_t agent);
	Direction finalPhase(Field& field, const uint_fast32_t agent);

private:

	//ゴール候補の選定
	void setAverageScore(const Field& field);
	void setSearchTarget(Field& field, const uint_fast32_t agent);
	static const bool _comp(std::pair<double, std::pair<uint_fast32_t, uint_fast32_t>>& lhs ,std::pair<double, std::pair<uint_fast32_t, uint_fast32_t>>& rhs);
	const double goalEvaluation(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord);

	
	//ゴール選定用の評価関数関連
	const int_fast32_t occupancyRate(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const uint_fast32_t occupancyMineRate(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const uint_fast32_t whosePanel(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const uint_fast32_t isSideOrAngle(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	
	const bool isOnDecidedRoute(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool isMyPannel(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool isInsideClosed(Field field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool isAngleCoord(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool isSideCoord(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	
	//ゴール候補選定
	const bool expectTarget(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool isOutOfRange(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool anotherAgentDistance(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	const bool anotherGoalDistance(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;

	
	//評価関数 & 位置関係所得
	const double heuristic(const std::pair<uint_fast32_t, uint_fast32_t>& coord, const std::pair<uint_fast32_t, uint_fast32_t>& goal) const;
	
	const bool isAdjacentAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr);
	const bool isAdjacentMineAgent(const Field& field, const uint_fast32_t agent);
	const bool isAdjacentEnemyAgent(const Field& field, const uint_fast32_t agent);
	
	const uint_fast32_t countAdjacentAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr);
	const uint_fast32_t countAdjacentMineAgent(const Field& field, const uint_fast32_t agent);
	const uint_fast32_t countAdjacentEnemyAgent(const Field& field, const uint_fast32_t agent);
	
	const double averageDistanceAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr);
	const double averageDistanceMineAgent(const Field& field, const uint_fast32_t agent);
	const double averageDistanceEnemyAgent(const Field& field, const uint_fast32_t agent);
	
	const uint_fast32_t countWithinRangeAgent(const Field& field, const uint_fast32_t agent, const double range, const uint_fast32_t attr);
	const uint_fast32_t countWithinRangeMineAgent(const Field& field, const uint_fast32_t agent, const double range);
	const uint_fast32_t countWithinRangeEnemyAgent(const Field& field, const uint_fast32_t agent, const double range);


	//探索関連
	void initNode(const Field& field, std::vector<Node>& node);
	static const bool comp(std::pair<Node*, Field>& lhs, std::pair<Node*, Field>& rhs);

	
  std::pair<int_fast32_t, std::vector<Node>> searchRoute(Field field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, const uint_fast32_t max_move_cost);	
	void setStartNode(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, Node* start);
	void setNextNode(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, Node* current, Node* next);


	//枝切り用
	const bool branchingCondition(Field& field, const uint_fast32_t agent, Node* current, const uint_fast32_t max_move_cost);
	const bool endCondition(Node* current) const;
	const bool isPushOpenlist(Field& field, Node* next) const;

	
	//時間管理
	const bool isTimeOver() const;

	
	//マルチスレッド用
	void multiThread(Field field, const uint_fast32_t agent, std::pair<uint_fast32_t, uint_fast32_t> coord);


	//最適ルート検索
	void searchBestRoute(Field& field, const uint_fast32_t agent);
	void search(Field& field, const uint_fast32_t attr);
	const std::vector<std::pair<uint_fast32_t, uint_fast32_t>> makeRoute(Field& field, std::vector<Node>& node, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal);
	void setDecidedCoord(const std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route);

	
	//描画関連
	const void printGoal(Field& field, const uint_fast32_t attr) const;
	const void printRoute(std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route);


	//アルゴリズムの選択
	void chooseAlgorithm(Field& field, const uint_fast32_t agent);
	void singleMove(Field& field, const uint_fast32_t agent);
	void correctionRoute(Field& field, const uint_fast32_t agent);

public:

	Astar();
	~Astar();

	void init(const Field* field) override;
	void init(const Field& field) override;
	void move(Field *field, const uint_fast32_t attr) override;

};

int_fast32_t expectedScore(Astar* astar, Field field, const uint_fast32_t agent);

/include/disp.hpp
#pragma once

#include <iostream>
#include <algorithm>
#include <string>
#include <utility>
#include <GL/glut.h>
#include "field.hpp"
#include "ai.hpp"

class Field;

const std::vector<int> vec_x = {0, 1, 1, 1, 0, -1, -1, -1, 0};
const std::vector<int> vec_y = {-1, -1, 0, 1, 1, 1, 0, -1, 0};

constexpr uint_fast32_t cell_size  = 30;
constexpr uint_fast32_t half = cell_size / 2;

constexpr uint_fast32_t line_size  = 1;
constexpr uint_fast32_t panel_size = 30;
constexpr uint_fast32_t agent_size = 15;
constexpr uint_fast32_t point_size = 15;

class Print{
private:

private:

	void renderString(float x, float y, const std::string& str) const;
	
public:

	Print();
	~Print();

	void line(const Field* field) const;
	void score(const Field* field) const;
	void panel(const Field* field) const;
	void agent(Field* field) const;
	void agentNum(Field* field) const;
	void point(const Field* field) const;
	void candidate(Field* field, const std::vector<Direction>& next) const;

	virtual void print(Field* field, const std::vector<Direction> next) = 0;
	virtual void print(Field* field) = 0;
	
};

class PrintDisplay : public Print{
private:
public:
	
	PrintDisplay();
	~PrintDisplay();
	
	void print(Field* field, const std::vector<Direction> next) override;
	void print(Field* field) override;
};

class PrintSelfDirectedGame : public Print{
private:
public:
	
	PrintSelfDirectedGame();
	~PrintSelfDirectedGame();
	
	void print(Field* field, const std::vector<Direction> next) override;
	void print(Field* field) override;
	
};

class Display;
class AI;
class RandomMine;
class RandomEnemy;

constexpr unsigned int window_width_size      = 800;
constexpr unsigned int window_height_size     = 800;
constexpr unsigned int window_width_position  = 100;
constexpr unsigned int window_height_position = 100;

class DisplayWrapper{
private:

	static DisplayWrapper* instance;

public:

	Field* field;
	Print* print;
	
	AI* random;
	AI* astar;
	AI* greedy;
	
	AI* beam_search;
	AI* breadth_force_search;
	

	DisplayWrapper();
	virtual ~DisplayWrapper();
	
	void init();
	void start(int argc, char *argv[]);
	void setField(Field* object);
	
	static void resizeWrapper(int w, int h);
	static void displayWrapper();
	static void keyboardWrapper(unsigned char key, int x, int y);
	static void specialKeyboardWrapper(int key, int x, int y);
	static void mouseWrapper(int button, int state, int x, int y);
	static void motionWrapper(int x, int y);
	static void setInstance(DisplayWrapper* framework);

	virtual void initInstance() = 0;
	virtual void resize(int w, int h) = 0;
	virtual void display() = 0;
	virtual void keyboard(unsigned char key, int x, int y) = 0;
	virtual void specialKeyboard(int key, int x, int y) = 0;
	virtual void mouse(int button, int state, int x, int y) = 0;
	virtual void motion(int x, int y) = 0;
	
};

class Display : public DisplayWrapper{
private:
	
	std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>> possible;
	std::vector<Direction> next;

	//agent_flag == 0:mineの入力 agent_flag == 1:enemyの入力
	//bool agent_flag;
	//uint_fast32_t enemy_flag;
	
	uint_fast32_t mine_flag;

	/*
	void setPossible();
	void moveNext();
	void selectAgent(uint_fast32_t x, uint_fast32_t y);
	void selectDirection(uint_fast32_t x, uint_fast32_t y);
	*/

	void setPossible();
	void moveNext();
	bool selectAgent(uint_fast32_t x, uint_fast32_t y);
	void selectDirection(uint_fast32_t x, uint_fast32_t y);
	const Direction changeDirection(const std::pair<uint_fast32_t, uint_fast32_t>& now, const std::pair<uint_fast32_t, uint_fast32_t>& next) const;
	
	void init();
	const bool isOutOfRange(int button, int state, int x, int y) const;
	
public:

 	Display();
 	~Display();

	void initInstance();
 	void resize(int w, int h) override;
 	void display() override;
 	void keyboard(unsigned char key, int x, int y) override;
 	void specialKeyboard(int key, int x, int y) override;
 	void mouse(int button, int state, int x, int y) override;
 	void motion(int x, int y) override;
	
};

inline const Direction Display::changeDirection(const std::pair<uint_fast32_t, uint_fast32_t>& now, const std::pair<uint_fast32_t, uint_fast32_t>& next) const{
	for(size_t i = 0; i < DIRECTION_SIZE - 2; i++)
		if(next.first == now.first + vec_x.at(i) && next.second == now.second + vec_y.at(i))
			return (Direction)i;
}

class selfDirectedGame : public DisplayWrapper {
private:
	
public:
	
	selfDirectedGame();
	~selfDirectedGame();
	
	void resize(int w, int h) override;
	void display() override;
	void keyboard(unsigned char key, int x, int y) override;
	void specialKeyboard(int key, int x, int y) override;
	void mouse(int button, int state, int x, int y) override;
	void motion(int x, int y) override;
	
};

/include/evaluator.hpp
#pragma once
#include "field.hpp"

class Evaluator{
private:
public:	
	virtual double evalutor(const Field& field)=0;
};

/include/field.hpp
#pragma once

#include <iostream>
#include <cmath>
#include <vector>
#include <unordered_map>
#include <cstdio>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <algorithm>
#include <numeric>
#include <climits>
#include <mutex>
#include <thread>
#include "picojson.h"
#include "agent.hpp"
#include "useful.hpp"
#include "disp.hpp"

constexpr uint_fast32_t MINE_ATTR = 0b01;
constexpr uint_fast32_t ENEMY_ATTR = 0b10;
constexpr uint_fast32_t PURE_ATTR = 0b00;

class Field;
class Agent;
class Display;
class DisplayWrapper;
/*
 * Panel 一つ一つの情報を管理するクラス
 */
class Panel {
	friend Field;
private:
	struct {
		// パネルのスコア
		// -16 <= value <= 16
		int_fast32_t value: 6;

		// パネルの属性を格納
		// 01:味方パネル 10:敵パネル 00:未占領 11:エラー
		// XXX 支配者 XXX
		uint_fast32_t attr: 2;
	};

	// パネルにスコアを代入
	void setValue(int_fast32_t value);

public:
	Panel();
	Panel(int_fast32_t value);

	// 持ち主は誰か
	// ex. isMyPanel() == true => 味方パネル
	bool isMyPanel() const;
	bool isEnemyPanel() const;
	bool isPurePanel() const;
	uint_fast32_t getAttr() const;

	// 持ち主のセット
	// ex. setMine() -> 味方パネルへ
	void setMine();
	void setEnemy();
	void setPure();

	// パネルのスコアを所得
	int_fast32_t getValue() const;
};

/*
 * Field 一つ一つ
 */
class Field {

	friend DisplayWrapper;
	friend Display;

private:

  //ターン数
	uint_fast32_t turn;

	//最終ターン
	uint_fast32_t max_turn;

	// フィールドの実幅、実高さ
	uint_fast32_t width, height;

	// 次の行に行くために必要なyのシフト数
	uint_fast32_t yShiftOffset;

	// 乱数生成器
	XorOshiro128p random;

	std::vector<Panel> field;

	// agentの動作可能かベクター
	std::vector<bool> canmoveAgents;

	// 実座標からfieldのインデックスを取り出す関数
	uint_fast32_t xyIndex(uint_fast32_t x, uint_fast32_t y);

	// fieldのインデックスから実座標を所得
	uint_fast32_t indexY(uint_fast32_t index) {
		return index / (field.size() / height);
	}
	uint_fast32_t indexX(uint_fast32_t index) {
		return index - indexY(index) * (field.size() / height);
	}

	// 実座標(x,y)のパネルにスコアをセット
	void setPanelScore(uint_fast32_t x, uint_fast32_t y, int_fast32_t value);

	// 実座標(x,y)のパネルの属性をセット
	void setPanelAttr(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr);

	// 得点計算関係
	UF makePureTreeMine();
	UF makePureTreeEnemy();
	std::unordered_map<int_fast32_t , std::vector<int_fast32_t>> makePureTerritory(UF &&pureTree);
	bool isPanelMineBetween(uint_fast32_t x, uint_fast32_t y);
	bool isPanelEnemyBetween(uint_fast32_t x, uint_fast32_t y);
	bool checkLocalArea(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr);
	int_fast32_t calcMineScore(std::unordered_map<int_fast32_t , std::vector<int_fast32_t>> &pureTree);
	int_fast32_t calcEnemyScore(std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> &pureTree);

public:

	void genRandMap();
	std::vector<Agent> agents;
	std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>> decided_route;

	// agentがdirectionの方向に動けるかどうか true:動ける false:動けない
	bool canMove(Agent &agent, Direction direction);

	// agentsの(nextX,nextY)を適用する
	// 行きたい座標が重なるなどしたときその場に止まるように指示
	void applyNextAgents();

	Field();
	Field(uint_fast32_t width, uint_fast32_t height);
	// MINE, ENEMY属性のパネルの置かれているところの合計点数を所得
	int_fast32_t calcMinepanelScore();
	int_fast32_t calcEnemypanelScore();

	// スコア計算m
	int_fast32_t calcScore(uint_fast32_t attr);

	// 実座標(x,y)のパネルのポインタを所得(const)
	const Panel *at(uint_fast32_t x, uint_fast32_t y) const;

	// テスト用. ランダムな方向へエージェントが移動する
	void testMoveAgent();

	// コンソール上に表示(テスト用)
	void print();

  //width、heightを外部から所得
	const uint_fast32_t getWidth() const;
	const uint_fast32_t getHeight() const;

	//turnを外部から所得
	const uint_fast32_t getTurn() const;

	//max_turnを外部から所得
	const uint_fast32_t getMaxTurn() const;

	//終了条件
	const bool checkEnd() const;

	//照射判定
	void judgeWinner();

  //fieldの初期化
	void init();
	
	//指定した座標が囲われているか判定
	bool is_inside_closed(const std::pair<uint_fast32_t, uint_fast32_t>& coord) const;
	void setPanels(const std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>>& decided_route, const uint_fast32_t attr, const uint_fast32_t depth) const;

	 //fieldの更新
  void update();
	
};

/include/useful.hpp
#pragma once

#include <ctime>
#include <cstdint>
#include <cstdio>
#include <random>
#include <string>
#include <vector>
#include <algorithm>

// UnionFind クラス
class UF {
private:
	std::vector<int_fast32_t> rank;
	std::vector<int_fast32_t> data;

public:
	UF(uint_fast32_t size);

	inline int_fast32_t root(int_fast32_t x) {
		return data[x] == x ? x : data[x] = root(data[x]);
	}

	inline bool same(int_fast32_t x, int_fast32_t y) {
		return root(x) == root(y);
	}

	inline void unite(int_fast32_t x, int_fast32_t y) {
		x = root(x);
		y = root(y);
		if(x == y) return;

		if(rank[x] < rank[y]) {
			data[x] = y;
		} else {
			data[y] = x;
			if(rank[x] == rank[y]) rank[x]++;
		}
	}
};

// グラフ表示するやつ
// template使うのでヘッダに実装
template <typename T>
class DPlot {
private:
	// データ
	std::vector<T> data;

public:
	DPlot(std::vector<T> data):data(data) {
	}

	T calcMean();

	// ヒストグラム生成
	void histogram(std::string color = "c") {
		// 現在のデータをファイル書き出し
		FILE *fp = fopen("data.txt", "w");
		for(uint_fast32_t i = 0; i < this->data.size(); i++) fprintf(fp, "%s\n", std::to_string(this->data[i]).c_str());
		fclose(fp);

		// gnuplot
		FILE *gp = popen("python", "w");

		fprintf(gp, "import numpy as np\nfrom matplotlib import pyplot\n");
		fprintf(gp, "data = np.loadtxt('data.txt')\n");
		fprintf(gp, "pyplot.hist(data, bins=%u, color='%s')\n", (uint_fast32_t)(this->data.size()/100), color.c_str());
		fprintf(gp, "pyplot.show()\n");
		pclose(gp);

		std::remove("data.txt");
	}
};

class enumName {
private:
	std::vector<std::string> args;
	std::string buf = "";

	void argSplit(std::string str) {	// split ','
		char charactor;
		int currentPos = 0;
		while((unsigned int)currentPos < str.size()) {
			charactor = str[currentPos++];
			if(std::isspace(charactor)) continue;
			if(currentPos == str.size()) {
				buf += charactor;
				args.emplace_back(buf);
				break;
			}
			if(charactor != ',') buf += charactor;
			else {
				args.emplace_back(buf);
				buf = "";
			}
		}
	}

public:
	enumName(std::string enums) {
		argSplit(enums);
	}
	std::string operator[](int i) {
		return args[i];
	}
};

#define DECLARE_ENUM(enumname, enumstr, ...) \
enum enumname { __VA_ARGS__ }; \
static enumName enumstr(#__VA_ARGS__); 

// Direction型
// direction2name[UP] = "UP" など
DECLARE_ENUM(Direction, direction2name, UP, RUP, RIGHT, RDOWN, DOWN, LDOWN, LEFT, LUP, STOP ,NONE, DIRECTION_SIZE);

// Direction型からx,yを所得
int_fast32_t direction2x(Direction direction);
int_fast32_t direction2y(Direction direction);

// x, yの変化量から方向を所得
Direction xyToDirection(int_fast32_t dx, int_fast32_t dy);

// 乱数生成器
// 高速で性質がいいため128bitのXoroshiro+法を選択
// Xorshift に比べていい乱数がでるし高速
// 64bit
class XorOshiro128p {
private:
	uint_fast64_t seed[2];

	static uint_fast64_t rotl(uint_fast64_t x, int_fast32_t k);

	static uint_fast64_t splitmix64(uint_fast64_t z);

public:
	XorOshiro128p();
	XorOshiro128p(uint_fast64_t seed);

	// それぞれ同じ処理を実装しているのは高速化のため(関数呼び出しのコストが大きい)
	
	uint_fast64_t operator()() {
		uint_fast64_t s0 = this->seed[0], s1 = this->seed[1], result = s0 + s1;
		s1 ^= s0; 
		this->seed[0] = ((s0 << 55) | (s0 >> (64 - 55))) ^ s1 ^ (s1 << 14);
		this->seed[1] = ((s1 << 36) | (s1 >> (64 - 36)));
		return result;
	}

	// [0, max] の整数
	uint_fast64_t operator()(uint_fast64_t max) {
		uint_fast64_t s0 = this->seed[0], s1 = this->seed[1], result = s0 + s1;
		s1 ^= s0; 
		this->seed[0] = ((s0 << 55) | (s0 >> (64 - 55))) ^ s1 ^ (s1 << 14);
		this->seed[1] = ((s1 << 36) | (s1 >> (64 - 36)));

		// modulo bias がかかってしまうがパフォーマンスを考えると難しい
		return result % (max + 1);
	}

	// [0, 1) の範囲で乱数を生成する
	inline double gend() {
		uint_fast64_t s0 = this->seed[0], s1 = this->seed[1], result = s0 + s1;
		s1 ^= s0; 
		this->seed[0] = ((s0 << 55) | (s0 >> (64 - 55))) ^ s1 ^ (s1 << 14);
		this->seed[1] = ((s1 << 36) | (s1 >> (64 - 36)));
		return (result >> 11) * (1. / (UINT64_C(1) << 53));
	}

	// [0, max) の実数
	// モジュロバイアスどうにかならんのか
	inline double gend(double max) {
		uint_fast64_t s0 = this->seed[0], s1 = this->seed[1], result = s0 + s1;
		s1 ^= s0; 
		this->seed[0] = ((s0 << 55) | (s0 >> (64 - 55))) ^ s1 ^ (s1 << 14);
		this->seed[1] = ((s1 << 36) | (s1 >> (64 - 36)));
		double decimal = (result >> 11) * (1. / (UINT64_C(1) << 53));

		return decimal * max;
	}

	inline bool genb() {
		return (this->gend() < 0.5) ? true : false;
	}
};
	
inline uint_fast64_t XorOshiro128p::splitmix64(uint_fast64_t z) {
	z += 0x9e3779b97f4a7c15;
	z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
	z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
	return z ^ (z >> 31);
}

/src/agent.cpp
#include "agent.hpp"

Agent::Agent() {
}

Agent::Agent(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr):x(x),y(y),attr(attr) {
}

Agent::Agent(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr, uint_fast32_t id):x(x),y(y),attr(attr),agent_id(id) {
}

void Agent::move(Direction direction) {
	this->nextX = this->x + direction2x(direction);
	this->nextY = this->y + direction2y(direction);
}

uint_fast32_t Agent::getX() {
	return this->x;
}

uint_fast32_t Agent::getY() {
	return this->y;
}

uint_fast32_t Agent::getnextX() {
	return this->nextX;
}

uint_fast32_t Agent::getnextY() {
	return this->nextY;
}

void Agent::setnextbufXY(uint_fast32_t nextbufX, uint_fast32_t nextbufY) {
	this->nextbufX = nextbufX;
	this->nextbufY = nextbufY;
}

uint_fast32_t Agent::getnextbufX() const {
	return this->nextbufX;
}

uint_fast32_t Agent::getnextbufY() const {
	return this->nextbufY;
}

uint_fast32_t Agent::getAttr() {
	return this->attr;
}

uint_fast32_t Agent::getID() {
	return this->agent_id;
}

void Agent::setNext() {
	this->x = this->nextX;
	this->y = this->nextY;
}

void Agent::reverseAttr(){
	this->attr = this->attr ^ 0b11;
}

/src/ai.cpp
#include "ai.hpp"

//----------------AI--------------

AI::AI(){
}

AI::~AI(){
}

int_fast32_t AI::nextScore(Field field, const uint_fast32_t agent, const Direction direction) const{
	field.agents.at(agent).move(direction);
	field.applyNextAgents();
	if(field.agents.at(agent).getAttr() == MINE_ATTR)
		return field.calcScore(MINE_ATTR) - field.calcScore(ENEMY_ATTR);
	else
		return field.calcScore(ENEMY_ATTR) - field.calcScore(MINE_ATTR);
	return false;
}

const bool AI::MineComp(std::pair<Field, Field>& lhs, std::pair<Field, Field>& rhs){
	int_fast32_t left_score  = lhs.second.calcScore(MINE_ATTR) - lhs.second.calcScore(ENEMY_ATTR);
	int_fast32_t right_score = rhs.second.calcScore(MINE_ATTR) - rhs.second.calcScore(ENEMY_ATTR);	
	
	bool result = left_score != right_score;
	return (result ? left_score > right_score : left_score > right_score);
}

const bool AI::EnemyComp(std::pair<Field, Field>& lhs, std::pair<Field, Field>& rhs){
	int_fast32_t left_score  = lhs.second.calcScore(ENEMY_ATTR) - lhs.second.calcScore(MINE_ATTR);
	int_fast32_t right_score = rhs.second.calcScore(ENEMY_ATTR) - rhs.second.calcScore(MINE_ATTR);
	
	bool result = left_score != right_score;
	return (result ? left_score > right_score : left_score > right_score);
}


//----------------Random--------------

Random::Random(){
	this->random = XorOshiro128p(time(NULL));
}

Random::~Random(){
}

void Random::init(const Field* field){
}

void Random::init(const Field& field){
}

void Random::move(Field *field, const uint_fast32_t attr){
	Field tmp = static_cast<Field> (*field);
	uint_fast32_t count = 0;
	Direction direction;
	
	for(auto &i: tmp.agents) {
		if(i.getAttr() == attr){
RE_CONSIDER:
			if(count++ > 10)
				break;
			direction = (Direction)(this->random(DIRECTION_SIZE - 2));
			if(tmp.canMove(i, direction))
				i.move(direction);
			else
				goto RE_CONSIDER;
		}
	}
	
	*field = tmp;	
}

//----------------Greedy--------------

Greedy::Greedy(){
	this->random = XorOshiro128p(time(NULL));
}

Greedy::~Greedy(){	
}

void Greedy::init(const Field* field){
}

void Greedy::init(const Field& field){
}

void Greedy::singleMove(Field& field, const uint_fast32_t agent){
	int_fast32_t max_score     = - INT_MAX;
	int_fast32_t next_score    = - INT_MAX;
	int_fast32_t current_score;
	Direction direction      = STOP;
	
	if(field.agents.at(agent).getAttr() == MINE_ATTR)
		current_score = field.calcScore(MINE_ATTR) - field.calcScore(ENEMY_ATTR);
	else
		current_score = field.calcScore(ENEMY_ATTR) - field.calcScore(MINE_ATTR);
	
	for(size_t i = 0; i < DIRECTION_SIZE - 2; i++){
		if(field.canMove(field.agents.at(agent), (Direction)i)){
			next_score = this->nextScore(field, agent, (Direction)i);
			if(next_score <= current_score)
				continue;
			if(next_score > max_score){
				max_score = next_score;
				direction = (Direction)i;
			}
		}
	}
	
	if(max_score <= current_score)
		this->randomMove(field, agent, field.agents.at(agent).getX(), field.agents.at(agent).getY());
	else
		field.agents.at(agent).move(direction);
}

void Greedy::randomMove(Field& field, const uint_fast32_t agent, const uint_fast32_t x, const uint_fast32_t y){
	Direction direction = STOP;
	uint_fast32_t count = 0;
	while(true){
		if(count++ > 10)
			break;
		direction = (Direction)(this->random(DIRECTION_SIZE - 3));
		if(field.at(x + this->vec_x.at(direction), y + this->vec_y.at(direction))->getValue() < -5)
			continue;
		if(field.canMove(field.agents.at(agent), direction)){
			field.agents.at(agent).move(direction);
			return;
		}
	}
}

void Greedy::move(Field *field, const uint_fast32_t attr){
	Field tmp = static_cast<Field> (*field);
	for(size_t i =0; i < tmp.agents.size(); i++)
		if(tmp.agents.at(i).getAttr() == attr)
			this->singleMove(tmp, i);
	*field = tmp;
}

//----------------BeamSearch--------------

BeamSearch::BeamSearch(){
}

BeamSearch::~BeamSearch(){	
}

void BeamSearch::init(const Field* field){
}

void BeamSearch::init(const Field& field){
}

Field BeamSearch::search(Field* field, const uint_fast32_t agent, uint_fast32_t depth){
	if(depth == 0 || field->checkEnd())
		return *field;
	
	std::vector<std::pair<Field, Field>> fields;
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field->canMove(field->agents.at(agent), (Direction)i)){
			Field fbuf = *field;
			fbuf.agents.at(agent).move((Direction)i);

			
			fbuf.applyNextAgents();
			fields.emplace_back(fbuf, fbuf);
		}
	}
	
	for(size_t i = 0; i < fields.size(); i++)
		fields.at(i).second = this->search(&fields.at(i).first, agent, depth - 1);

	if(field->agents.at(agent).getAttr() == MINE_ATTR)
		std::sort(fields.begin(), fields.end(), MineComp);
	else
		std::sort(fields.begin(), fields.end(), EnemyComp);

	if(fields.size() > beam_width)
		fields.erase(fields.begin() + beam_width, fields.end());
	
	return fields.at(0).first;
}
	
void BeamSearch::singleMove(Field& field, const uint_fast32_t agent){
	const Field current_field = field;
	Field next_field    = this->search(&current_field, agent, beam_depth);
	
	std::pair<uint_fast32_t, uint_fast32_t> current_coord = std::make_pair(current_field.agents.at(agent).getX(), current_field.agents.at(agent).getY()); 
	std::pair<uint_fast32_t, uint_fast32_t> next_coord    = std::make_pair(next_field.agents.at(agent).getnextbufX(), next_field.agents.at(agent).getnextbufY());
	
	Direction direction = this->changeDirection(current_coord, next_coord);
	if(field.canMove(field.agents.at(agent), direction))
		field.agents.at(agent).move(direction);
}

void BeamSearch::move(Field* field, const uint_fast32_t attr){
	Field tmp = static_cast<Field> (*field);
	for(size_t i =0; i < tmp.agents.size(); i++)
		if(tmp.agents.at(i).getAttr() == attr)
			this->singleMove(tmp, i);
	*field = tmp;
}

//----------------BreadthForceSearch--------------

BreadthForceSearch::BreadthForceSearch(){
}

BreadthForceSearch::~BreadthForceSearch(){
}

void BreadthForceSearch::init(const Field* field){
	;
}

void BreadthForceSearch::init(const Field& field){
	;
}

Field BreadthForceSearch::search(Field* field, const uint_fast32_t agent,  uint_fast32_t depth){
	if(depth == 0 || field->checkEnd())
		return *field;
	
	std::vector<std::pair<Field, Field>> fields;
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++) {
		if(field->canMove(field->agents.at(agent), (Direction)i)){
			Field fbuf = *field;
			fbuf.agents.at(agent).move((Direction)i);
			fbuf.applyNextAgents();
			fields.emplace_back(fbuf, fbuf);
		}
	}
	
	for(size_t i = 0; i < fields.size(); i++)
		fields.at(i).second = this->search(&fields.at(i).first, agent, depth - 1);

	if(field->agents.at(agent).getAttr() == MINE_ATTR)
		std::sort(fields.begin(), fields.end(), MineComp);
	else
		std::sort(fields.begin(), fields.end(), EnemyComp);
	
	return fields.at(0).first;
}

void BreadthForceSearch::singleMove(Field& field, const uint_fast32_t agent){
	const Field current_field = field;
	Field next_field    = this->search(&field, agent, bfs_depth);
	
	std::pair<uint_fast32_t, uint_fast32_t> current_coord = std::make_pair(current_field.agents.at(agent).getX(), current_field.agents.at(agent).getY()); 
	std::pair<uint_fast32_t, uint_fast32_t> next_coord    = std::make_pair(next_field.agents.at(agent).getX(), next_field.agents.at(agent).getY()); 

	Direction direction = this->changeDirection(current_coord, next_coord);
	if(field.canMove(field.agents.at(agent), direction))
		field.agents.at(agent).move(direction);
}

void BreadthForceSearch::move(Field *field, const uint_fast32_t attr){
	Field tmp = static_cast<Field> (*field);
	for(size_t i =0; i < tmp.agents.size(); i++)
		if(tmp.agents.at(i).getAttr() == attr)
			this->singleMove(tmp, i);
	*field = tmp;
}

//----------------Node--------------

Node::Node(){
	this->status = NONE;
	this->parent = nullptr;
}

Node::~Node(){
}

//----------------SimpleMove--------------

SimpleMove::SimpleMove(){
	
}

SimpleMove::~SimpleMove(){
	
}

void SimpleMove::greedyMove(Field& field, const uint_fast32_t agent, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& decided_coord){	
	Direction direction = STOP;
	const uint_fast32_t attr = field.agents.at(agent).getAttr();

	this->next_coord.clear();
	
	for(size_t i = 0; i < field.agents.size(); i++)
		if(field.agents.at(i).getAttr() != field.agents.at(agent).getAttr())
			this->greedySingleMove(field, i, attr, decided_coord);

	for(size_t i = agent + 1; i < field.agents.size(); i++)
		if(field.agents.at(i).getAttr() == field.agents.at(agent).getAttr())
			this->greedySingleMove(field, i, attr, decided_coord);
}

void SimpleMove::greedySingleMove(Field& field, const uint_fast32_t agent, const uint_fast32_t attr, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& decided_coord){
	Direction direction = STOP;
	int_fast32_t score = -INT_MAX, max_score = -INT_MAX;
	
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field.canMove(field.agents.at(agent), i)){
			score = field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getValue();

			if(field.agents.at(agent).getAttr() == attr){
				auto result = std::find(decided_coord.begin(), decided_coord.end(), std::make_pair(x + this->vec_x.at(i), y + this->vec_y.at(i)));
				if(result != decided_coord.end())
					score -= 50;
			}
			else{
				auto result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(x + this->vec_x.at(i), y + this->vec_y.at(i)));
				if(result != this->next_coord.end())
					continue;
			}
			
			if(field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getAttr() == field.agents.at(agent).getAttr())
				score -= 100;
			if(score > max_score){
				max_score = score;
				direction = (Direction)i;
			}
		}
	}
	field.agents.at(agent).move(direction);
	this->next_coord.emplace_back(std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
}

void SimpleMove::greedyMove(Field& field, const uint_fast32_t agent){
	Direction direction = STOP;
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	
	for(size_t i = 0; i < field.agents.size(); i++)
		if(field.agents.at(i).getAttr() != field.agents.at(agent).getAttr())
			this->greedySingleMove(field, i, attr);
}

void SimpleMove::greedySingleMove(Field& field, const uint_fast32_t agent, const uint_fast32_t attr){
	Direction direction = STOP;
	int_fast32_t score = -INT_MAX, max_score = -INT_MAX;
	
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field.canMove(field.agents.at(agent), i)){
			score = field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getValue();

			if(field.agents.at(agent).getAttr() != attr){
				auto result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(x + this->vec_x.at(i), y + this->vec_y.at(i)));
				if(result != this->next_coord.end())
					continue;
			}
			
			if(field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getAttr() == field.agents.at(agent).getAttr())
				score -= 100;
			if(score > max_score){
				max_score = score;
				direction = (Direction)i;
			}
		}
	}
	field.agents.at(agent).move(direction);
}

const Direction SimpleMove::greedySingleMove(Field& field, const uint_fast32_t agent, const std::vector<std::pair<uint_fast32_t, uint_fast32_t>>& expect_coord) const{
	Direction direction = STOP;
	int_fast32_t score = -INT_MAX, max_score = -INT_MAX;
	
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field.canMove(field.agents.at(agent), i)){
			score = field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getValue();

			auto result = std::find(expect_coord.begin(), expect_coord.end(), std::make_pair(x + this->vec_x.at(i), y + this->vec_y.at(i)));
			if(result != expect_coord.end())
				continue;

			if(field.at(x + this->vec_x.at(i), y + this->vec_y.at(i))->getAttr() == field.agents.at(agent).getAttr())
				score -= 10;
			if(score > max_score){
				max_score = score;
				direction = (Direction)i;
			}
		}
	}
	return direction;
}

Field SimpleMove::beamSearch(Field* field, const uint_fast32_t agent, uint_fast32_t depth) const{
	if(depth == 0 || field->checkEnd())
		return *field;
	
	std::vector<std::pair<Field, Field>> fields;
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field->canMove(field->agents.at(agent), (Direction)i)){
			Field fbuf = *field;
			fbuf.agents.at(agent).move((Direction)i);
			this->greedyMove(fbuf, agent);
			fbuf.applyNextAgents();
			fields.emplace_back(fbuf, fbuf);
		}
	}
	
	for(size_t i = 0; i < fields.size(); i++)
		fields.at(i).second = this->beamSearch(&fields.at(i).first, agent, depth - 1);

	if(field->agents.at(agent).getAttr() == MINE_ATTR)
		std::sort(fields.begin(), fields.end(), MineComp);
	else
		std::sort(fields.begin(), fields.end(), EnemyComp);

	if(fields.size() > simple_beam_width)
		fields.erase(fields.begin() + beam_width, fields.end());
	
	return fields.at(0).first;
}

const Direction SimpleMove::beamSearchSingleMove(Field field, const uint_fast32_t agent) const{
	const Field current_field = field;
	Field next_field    = this->beamSearch(&current_field, agent, simple_beam_depth);
	
	std::pair<uint_fast32_t, uint_fast32_t> current_coord = std::make_pair(current_field.agents.at(agent).getX(), current_field.agents.at(agent).getY()); 
	std::pair<uint_fast32_t, uint_fast32_t> next_coord    = std::make_pair(next_field.agents.at(agent).getnextbufX(), next_field.agents.at(agent).getnextbufY());
	
	Direction direction = this->changeDirection(current_coord, next_coord);
	
	if(field.canMove(field.agents.at(agent), direction))
		return direction;
	return STOP;
}

void SimpleMove::beamSearchMove(Field& field, const uint_fast32_t attr) const{
	Direction direction = STOP;
	
	for(size_t i =0; i < field.agents.size(); i++){
		if(field.agents.at(i).getAttr() == attr){
			direction = this->beamSearchSingleMove(field, i);
			field.agents.at(i).move(direction);
		}
	}
}

Field SimpleMove::breadthForceSearch(Field* field, const uint_fast32_t agent, uint_fast32_t depth) const{
	if(depth == 0 || field->checkEnd())
		return *field;
	
	std::vector<std::pair<Field, Field>> fields;
	
	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		if(field->canMove(field->agents.at(agent), (Direction)i)){
			Field fbuf = *field;
			fbuf.agents.at(agent).move((Direction)i);
			this->greedyMove(fbuf, agent);
			fbuf.applyNextAgents();
			fields.emplace_back(fbuf, fbuf);
		}
	}
	
	for(size_t i = 0; i < fields.size(); i++)
		fields.at(i).second = this->beamSearch(&fields.at(i).first, agent, depth - 1);

	if(field->agents.at(agent).getAttr() == MINE_ATTR)
		std::sort(fields.begin(), fields.end(), MineComp);
	else
		std::sort(fields.begin(), fields.end(), EnemyComp);
	
	return fields.at(0).first;
}

const Direction SimpleMove::breadthForceSearchSingleMove(Field& field, const uint_fast32_t agent) const{
	const Field current_field = field;
	Field next_field    = this->breadthForceSearch(&current_field, agent, simple_bfs_depth);
	
	std::pair<uint_fast32_t, uint_fast32_t> current_coord = std::make_pair(current_field.agents.at(agent).getX(), current_field.agents.at(agent).getY()); 
	std::pair<uint_fast32_t, uint_fast32_t> next_coord    = std::make_pair(next_field.agents.at(agent).getnextbufX(), next_field.agents.at(agent).getnextbufY());
	
	Direction direction = this->changeDirection(current_coord, next_coord);
	
	if(field.canMove(field.agents.at(agent), direction))
		return direction;
	return STOP;
}

void SimpleMove::breadthForceSearchSearchMove(Field& field, const uint_fast32_t attr) const{
	Direction direction = STOP;
	
	for(size_t i =0; i < field.agents.size(); i++){
		if(field.agents.at(i).getAttr() == attr){
			direction = this->breadthForceSearchSingleMove(field, i);
			field.agents.at(i).move(direction);
		}
	}
}

void SimpleMove::init(const Field* field){
}

void SimpleMove::init(const Field& field){
}
	
void SimpleMove::move(Field* field, const uint_fast32_t attr){
}

//----------------A*algorithm--------------

Astar::Astar(){
}

Astar::~Astar(){
}

void Astar::greedyMove(Field& field, const uint_fast32_t agent, const uint_fast32_t move_num){
	if(move_num > greedy_count){
		if(field.agents.at(field.agents.size() - 1).getAttr() != field.agents.at(agent).getAttr())
			field.agents.erase(field.agents.begin() + field.agents.size() / 2, field.agents.end());
		return;
	}
	simple_move.greedyMove(field, agent, this->decided_coord);
}

void Astar::decidedMove(Field& field, const uint_fast32_t agent, std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>>& route){
	Direction direction;
	for(size_t i = 0; i < field.agents.size(); i++){
		if(i == agent)
			continue;
		if(route.at(i).size() <= 1)
			continue;
		
		direction = this->changeDirection(route.at(i).at(0), route.at(i).at(1));
		if(field.canMove(field.agents.at(i), direction))
			field.agents.at(i).move(direction);
	}

	field.applyNextAgents();

	for(size_t i = 0; i < field.agents.size(); i++){
		if(route.at(i).size() <= 2)
			continue;
		if(field.agents.at(i).getX() == route.at(i).at(1).first && field.agents.at(i).getY() == route.at(i).at(1).second)
			route.at(i).erase(route.at(i).begin());
	}
}

Direction Astar::exceptionMove(Field& field, const uint_fast32_t agent){
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
	Direction direction;
	direction = simple_move.beamSearchSingleMove(field, agent);
	auto result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
	if(result == this->next_coord.end() && direction != STOP)
		return direction;
	direction = simple_move.greedySingleMove(field, agent, this->next_coord);
	return direction;
}

Direction Astar::finalPhase(Field& field, const uint_fast32_t agent){
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
	Direction direction;
	direction = simple_move.breadthForceSearchSingleMove(field, agent);
	auto result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
	if(result == this->next_coord.end() && direction != STOP)
		return direction;
	direction = simple_move.greedySingleMove(field, agent, this->next_coord);
	return direction;
}

void Astar::setAverageScore(const Field& field){
	int_fast32_t count = 0, sum = 0;
	for(size_t i = 0; i < field.getHeight(); i++){
		for(size_t j = 0; j < field.getWidth(); j++){
			sum += field.at(j, i)->getValue();
			count++;
		}
	}
	this->average_score = sum / count;
}

void Astar::setSearchTarget(Field& field, const uint_fast32_t agent){
	std::vector<std::pair<double, std::pair<uint_fast32_t, uint_fast32_t>>> condidate;
	double value;

	this->search_target.clear();
	for(size_t i = 0; i < field.getHeight(); i++) {
		for(size_t j = 0; j < field.getWidth(); j++) {
			value = this->goalEvaluation(field, agent, std::make_pair(j, i));
			if(value == false)
				continue;
			condidate.emplace_back(std::make_pair(value, std::make_pair(j, i)));
		}
	}
	std::sort(condidate.begin(), condidate.end(), _comp);
	for(size_t i = 0; i < astar_depth; i++){
		if(i >= condidate.size())
			break;
		this->search_target.emplace_back(condidate.at(i).second);
	}
}

const bool Astar::_comp(std::pair<double, std::pair<uint_fast32_t, uint_fast32_t>>& lhs ,std::pair<double, std::pair<uint_fast32_t, uint_fast32_t>>& rhs){
	bool result = lhs.first != rhs.first;
	return (result ? lhs.first > rhs.first : lhs.first > rhs.first);
}

const double Astar::goalEvaluation(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord){
	if(this->expectTarget(field, agent, coord))
		return false;
	return field.at(coord.first, coord.second)->getValue() + (this->occupancyRate(field, agent, coord) * occpancy_weight) - (this->isOnDecidedRoute(field, agent, coord) * is_on_decided_weight) - (isAngleCoord(field, coord) * is_angle_weight) - (isSideCoord(field, coord) * is_side_weight) - (isInsideClosed(field, agent, coord) * is_inside_closed_weight);
}

const int_fast32_t Astar::occupancyRate(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	int_fast32_t mine_count = 0, enemy_count = 0, pure_count = 0;
	for(size_t i = 0; i < DIRECTION_SIZE - 1; i++){
		if(this->whosePanel(field, agent, std::make_pair(coord.first + this->vec_x.at(i), coord.second + this->vec_y.at(i))) == MINE_ATTR)
			mine_count++;
		if(this->whosePanel(field, agent, std::make_pair(coord.first + this->vec_x.at(i), coord.second + this->vec_y.at(i))) == ENEMY_ATTR)
			enemy_count++;
		if(this->whosePanel(field, agent, std::make_pair(coord.first + this->vec_x.at(i), coord.second + this->vec_y.at(i))) == PURE_ATTR)
			pure_count++;
	}
	return enemy_count + pure_count - mine_count;
}

const uint_fast32_t Astar::occupancyMineRate(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	int_fast32_t mine_count = 0;
	for(size_t i = 0; i < DIRECTION_SIZE - 1; i++)
		if(this->whosePanel(field, agent, std::make_pair(coord.first + this->vec_x.at(i), coord.second + this->vec_y.at(i))) == MINE_ATTR)
			mine_count++;
	return mine_count;
}

const uint_fast32_t Astar::whosePanel(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	const uint_fast32_t	agent_attr  = field.agents.at(agent).getAttr();
	const uint_fast32_t	pannel_attr = field.at(coord.first, coord.second)->getAttr();
	uint_fast32_t attr = MINE_ATTR;
	
	if(pannel_attr == PURE_ATTR)
	  attr = PURE_ATTR;
	if(agent_attr == MINE_ATTR && pannel_attr == ENEMY_ATTR)
		attr = ENEMY_ATTR;
	if(agent_attr == ENEMY_ATTR && pannel_attr == MINE_ATTR)
		attr = ENEMY_ATTR;
	return attr;
}

const uint_fast32_t Astar::isSideOrAngle(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(coord.first == 0 && coord.second == 0 || coord.first == 0 && coord.second == field.getHeight() - 1 || coord.first == field.getWidth() - 1 && coord.second == 0 || coord.first == field.getWidth() - 1 && coord.second == field.getHeight() - 1)
		return ANGLE_COORD;
	if(coord.first == 0 || coord.second == 0 || coord.first == field.getWidth() - 1 || coord.second == field.getHeight() - 1)
		return SIDE_COORD;
	return false;
}

const bool Astar::isOnDecidedRoute(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(this->decided_coord.empty())
		return false;
	auto result = std::find(this->decided_coord.begin(), this->decided_coord.end(), coord);
	if(result != this->decided_coord.end())
		return true;
	return false;
}

const bool Astar::isMyPannel(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(this->whosePanel(field, agent, coord) == MINE_ATTR)
		return true;
	return false;
}

const bool Astar::isInsideClosed(Field field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	field.setPanels(this->decided_route, attr, search_count);
	if(field.is_inside_closed(coord))
		return true;
	return false;
}

const bool Astar::isAngleCoord(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(this->isSideOrAngle(field, coord) == ANGLE_COORD)
		return true;
	return false;
}

const bool Astar::isSideCoord(Field& field, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(this->isSideOrAngle(field, coord) == SIDE_COORD)
		return true;
	return false;
}

const bool Astar::expectTarget(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	if(field.agents.at(agent).getX() == coord.first && field.agents.at(agent).getY() == coord.second)
		return true;
	if(field.at(coord.first, coord.second)->getValue() <= this->average_score)
		return true;
	if(this->anotherAgentDistance(field, agent, coord))
		return true;
	if(this->anotherGoalDistance(field, agent, coord))
		return true;
	if(this->isOutOfRange(field, agent, coord))
		return true;
	if(this->isMyPannel(field, agent, coord))
		return true;
	if(this->occupancyMineRate(field, agent, coord) == 3)
		return true;
		
	return false;
}

const bool Astar::isOutOfRange(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	uint_fast32_t x = field.agents.at(agent).getX();
	uint_fast32_t y = field.agents.at(agent).getY();
	double mine_distance = this->heuristic(std::make_pair(x, y), coord);
	if(min_mine_distance >= max_mine_distance)
		if(mine_distance <= min_mine_distance)
			return true;
	if(mine_distance <= min_mine_distance || mine_distance >= max_mine_distance)
		return true;
}

const bool Astar::anotherAgentDistance(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	uint_fast32_t x = field.agents.at(agent).getX();
	uint_fast32_t y = field.agents.at(agent).getY();
	double another_distance, mine_distance = this->heuristic(std::make_pair(x, y), coord);
	for(size_t i = 0; i < field.agents.size(); i++){
		if(agent == i)
			continue;
		if(field.agents.at(agent).getAttr() != field.agents.at(i).getAttr())
			continue;
		another_distance = this->heuristic(std::make_pair(x, y), coord);
		if(another_distance <= mine_distance && another_distance <= min_agent_distance)
			return true;
	}
	return false;
}

const bool Astar::anotherGoalDistance(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	uint_fast32_t distance;
	for(size_t i = 0; i < agent; i++){
		if(field.agents.at(agent).getAttr() == field.agents.at(i).getAttr()){
			distance = this->heuristic(coord, this->decided_goal.at(i));
			if(distance <= min_goal_distance)
				return true;
		}
	}
	return false;
}

const double Astar::heuristic(const std::pair<uint_fast32_t, uint_fast32_t>& coord, const std::pair<uint_fast32_t, uint_fast32_t>& goal) const{
	const uint_fast32_t dx = std::abs((int_fast32_t)(goal.first - coord.first));
	const uint_fast32_t dy = std::abs((int_fast32_t)(goal.second - coord.second));
	const double distance  = std::sqrt(std::pow(dx, 2) + std::pow(dy, 2));
	return distance;
}

const bool Astar::isAdjacentAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr){
	if(attr == MINE_ATTR)
		return this->isAdjacentMineAgent(field, agent);
	if(attr == ENEMY_ATTR)
		return this->isAdjacentEnemyAgent(field, agent);
	return false;
}

const bool Astar::isAdjacentMineAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	bool flag = false;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr == agent.getAttr()){
					if(x + this->vec_x.at(i) == agent.getX() && y + this->vec_y.at(i) == agent.getY()){
						flag = true;
						return;
					}
				}
			});
	}
	return flag;
}

const bool Astar::isAdjacentEnemyAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	bool flag = false;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr != agent.getAttr()){
					if(x + this->vec_x.at(i) == agent.getX() && y + this->vec_y.at(i) == agent.getY()){
						flag = true;
						return;
					}
				}
			});
	}
	return flag;
}

const uint_fast32_t Astar::countAdjacentAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr){
	if(attr == MINE_ATTR)
		return this->countAdjacentMineAgent(field, agent);
	if(attr == ENEMY_ATTR)
		return this->countAdjacentEnemyAgent(field, agent);
	return 0;
}

const uint_fast32_t Astar::countAdjacentMineAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t count = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr == agent.getAttr())
					if(x + this->vec_x.at(i) == agent.getX() && y + this->vec_y.at(i) == agent.getY())
						count++;
			});
	}
	return count;
}
	
const uint_fast32_t Astar::countAdjacentEnemyAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t count = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr != agent.getAttr())
					if(x + this->vec_x.at(i) == agent.getX() && y + this->vec_y.at(i) == agent.getY())
						count++;
			});
	}
	return count;
}

const double Astar::averageDistanceAgent(const Field& field, const uint_fast32_t agent, const uint_fast32_t attr){
	if(attr == MINE_ATTR)
		return this->averageDistanceMineAgent(field, agent);
	if(attr == ENEMY_ATTR)
		return this->averageDistanceEnemyAgent(field, agent);
	return 0;
}

const double Astar::averageDistanceMineAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t sum = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr == agent.getAttr())
					sum += this->heuristic(std::make_pair(x, y), std::make_pair(agent.getX(), agent.getY()));
			});
	}
	return (double)sum / field.agents.size();
}

const double Astar::averageDistanceEnemyAgent(const Field& field, const uint_fast32_t agent){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t sum = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr != agent.getAttr())
					sum += this->heuristic(std::make_pair(x, y), std::make_pair(agent.getX(), agent.getY()));
			});
	}
	return (double)sum / field.agents.size();
}

const uint_fast32_t Astar::countWithinRangeAgent(const Field& field, const uint_fast32_t agent, const double range, const uint_fast32_t attr){
	if(attr == MINE_ATTR)
		return this->countWithinRangeMineAgent(field, agent, range);
	if(attr == ENEMY_ATTR)
		return this->countWithinRangeEnemyAgent(field, agent, range);
	return 0;
}

const uint_fast32_t Astar::countWithinRangeMineAgent(const Field& field, const uint_fast32_t agent, const double range){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t count = 0;
	double distance     = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr == agent.getAttr()){
					distance = this->heuristic(std::make_pair(x, y), std::make_pair(agent.getX(), agent.getY()));
					if(distance <= range) count++;
				}
			});
	}
	return count;
}

const uint_fast32_t Astar::countWithinRangeEnemyAgent(const Field& field, const uint_fast32_t agent, const double range){
	const uint_fast32_t x    = field.agents.at(agent).getX();
	const uint_fast32_t y    = field.agents.at(agent).getY();
	const uint_fast32_t attr = field.agents.at(agent).getAttr();
	uint_fast32_t count = 0;
	double distance     = 0;

	for(size_t i = 0; i < DIRECTION_SIZE - 3; i++){
		std::for_each(field.agents.begin(), field.agents.end(), [&, this](auto& agent){
				if(attr != agent.getAttr()){
					distance = this->heuristic(std::make_pair(x, y), std::make_pair(agent.getX(), agent.getY()));
					if(distance <= range) count++;
				}
			});
	}
	return count;
}

void Astar::initNode(const Field& field, std::vector<Node>& node){
	node.clear();
	node.resize(field.getWidth() * field.getHeight());
	for(size_t i = 0; i < field.getWidth(); i++)
		for(size_t j = 0; j < field.getHeight(); j++)
			node.at(j * field.getWidth() + i).coord = std::make_pair(i, j);
}

const bool Astar::comp(std::pair<Node*, Field>& lhs, std::pair<Node*, Field>& rhs){
	bool result = lhs.first->getScore() != rhs.first->getScore();
	return (result ? lhs.first->getScore() < rhs.first->getScore() : lhs.first->state_cost < rhs.first->state_cost);
}

std::pair<int_fast32_t, std::vector<Node>> Astar::searchRoute(Field field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, const uint_fast32_t max_move_cost){
	std::vector<std::pair<Node*, Field>> open;
	std::vector<Node> node;
	
	Node *start, *current , *next;
	Field current_field, next_field;
	int_fast32_t score;
	
	this->initNode(field, node);
	start =& node.at(field.agents.at(agent).getY() * field.getWidth() + field.agents.at(agent).getX());
	this->setStartNode(field, agent, goal, start);
	field.decided_route = this->decided_route;
	open.emplace_back(std::make_pair(start, field));
	
	while(!open.empty()){
		std::sort(open.begin(), open.end(), comp);
		current = open.at(0).first;
		current_field = open.at(0).second;
		
		if(this->branchingCondition(current_field, agent, current, max_move_cost))
			goto SKIP_NODE;

		if(this->isTimeOver()){
			this->is_time_over = true;
			return std::make_pair(-INT_MAX, node);
		}
		
		if(current->coord == goal){
			if(this->endCondition(current))
				goto SKIP_NODE;
			if(current_field.agents.at(agent).getAttr() == MINE_ATTR)
				score = ((current_field.calcScore(MINE_ATTR) - current_field.calcScore(ENEMY_ATTR)) * score_weight) + (this->goalEvaluation(field, agent, goal) * goal_weight) + (current->getScore() * cost_weight);
			else
				score = ((current_field.calcScore(ENEMY_ATTR) - current_field.calcScore(MINE_ATTR)) * score_weight) + (this->goalEvaluation(field, agent, goal) * goal_weight) + (current->getScore() * cost_weight);
			return std::make_pair(score, node);
		}
		
		for(size_t i = 0; i < DIRECTION_SIZE - 2; i++){
			if(current_field.canMove(current_field.agents.at(agent), (Direction)i)){
				next_field = current_field;
				next_field.agents.at(agent).move((Direction)i);
				this->greedyMove(next_field, agent, current->move_num);
				this->decidedMove(next_field, agent,  next_field.decided_route);
				next =& node.at(next_field.agents.at(agent).getY() * field.getWidth() + next_field.agents.at(agent).getX());
				
				if(current->coord == next->coord){
					next_field.agents.at(agent).move((Direction)i);
					this->greedyMove(next_field, agent, current->move_num + 1);
				  this->decidedMove(next_field, agent,  next_field.decided_route);
					next =& node.at(next_field.agents.at(agent).getY() * field.getWidth() + next_field.agents.at(agent).getX());

					if(current->coord == next->coord)
						continue;
					
					if(this->isPushOpenlist(next_field, next) && next->coord != current->coord){
						
						this->setNextNode(next_field, agent, goal, current, next);
						next->move_cost = current->move_cost + 2;
						open.emplace_back(std::make_pair(next, next_field));
					}
				}
				else{
					if(this->isPushOpenlist(next_field, next)){
						
						this->setNextNode(next_field, agent, goal, current, next);
						next->move_cost = current->move_cost + 1;
						open.emplace_back(std::make_pair(next, next_field));
					}
				}
			}
		}
		
	SKIP_NODE:
		current->status = Node::CLOSED;
		open.erase(open.begin());
	}

	return std::make_pair(-INT_MAX, node);
}

void Astar::setStartNode(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, Node* start){
	start->status              = Node::OPEN;
	start->move_cost           = 0;
	start->heuristic           = 0;
	start->is_on_decided_route = 0;
	
	start->is_on_mine_panel    = 0;
	start->is_on_enemy_panel   = 0;
	
	start->adjacent_agent      = 0;
	start->average_distance    = 0;
	start->move_num            = 0;
	start->state_cost          = 0;
	start->value               = 0;
}

void Astar::setNextNode(Field& field, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal, Node* current, Node* next){
	next->status               = Node::OPEN;
	next->heuristic            = this->heuristic(next->coord, goal);
	next->is_on_decided_route  = this->isOnDecidedRoute(field, agent, next->coord);
	next->adjacent_agent       = this->countAdjacentAgent(field, agent, MINE_ATTR);
	next->average_distance     = this->averageDistanceAgent(field, agent, MINE_ATTR);
	next->move_num             = current->move_num + 1;
	next->parent               = current;

	if(field.agents.at(agent).getAttr() == MINE_ATTR)
		next->state_cost         = field.calcScore(ENEMY_ATTR) - field.calcScore(MINE_ATTR);
	else
		next->state_cost         = field.calcScore(MINE_ATTR) - field.calcScore(ENEMY_ATTR);

	next->is_on_mine_panel     = false;
	if(field.agents.at(agent).getAttr() == MINE_ATTR && field.at(next->coord.first, next->coord.second)->isMyPanel())
		next->is_on_mine_panel   = true;
	if(field.agents.at(agent).getAttr() == ENEMY_ATTR && field.at(next->coord.first, next->coord.second)->isEnemyPanel())
		next->is_on_mine_panel   = true;

	next->is_on_enemy_panel    = false;
	if(field.agents.at(agent).getAttr() == MINE_ATTR && field.at(next->coord.first, next->coord.second)->isEnemyPanel())
		next->is_on_enemy_panel  = true;
	if(field.agents.at(agent).getAttr() == ENEMY_ATTR && field.at(next->coord.first, next->coord.second)->isMyPanel())
		next->is_on_enemy_panel  = true;

	if(field.agents.at(agent).getAttr() != field.at(next->coord.first, next->coord.second)->getAttr())
		next->value = field.at(next->coord.first, next->coord.second)->getValue();
	else
		next->value = false;
}

const bool Astar::branchingCondition(Field& field, const uint_fast32_t agent, Node* current, const uint_fast32_t max_move_cost){
	uint_fast32_t x = field.agents.at(agent).getX();
	uint_fast32_t y = field.agents.at(agent).getY();
	int_fast32_t value = field.at(x, y)->getValue();
	
	if(current->move_cost >= max_move_cost)
		return true;
	if(value <= -min_value)
		return true;
	return false;
}

const bool Astar::endCondition(Node* current) const{
	return (current->move_cost <= min_move_cost);
}

const bool Astar::isPushOpenlist(Field& field, Node* next) const{
	if(next->status == Node::NONE)
		return true;
	if(next->status == Node::OPEN)
		if(field.at(next->coord.first, next->coord.second)->getValue() >= min_open_list_value)
			return true;
	return false;
}

const bool Astar::isTimeOver() const{
	std::chrono::system_clock::time_point current = std::chrono::system_clock::now();
	double time    = std::chrono::duration_cast<std::chrono::milliseconds>(current - this->clock).count();
	if(time > search_time - grace_time)
		return true;
	
	return false;
}

void Astar::multiThread(Field field, const uint_fast32_t agent, std::pair<uint_fast32_t, uint_fast32_t> coord){
	std::pair<int_fast32_t, std::vector<Node>> condidate;
	int_fast32_t score;
	condidate = this->searchRoute(field, agent, coord, max_move);
	score     = condidate.first;
	if(score > this->tentative_max_score){
		this->tentative_max_score = score;
		this->tentative_goal      = coord;
		this->tentative_route     = this->makeRoute(field, condidate.second, agent, coord);
	}
}

void Astar::searchBestRoute(Field& field,const uint_fast32_t agent){
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route;
	std::chrono::system_clock::time_point start = std::chrono::system_clock::now();

	this->tentative_route.clear();
	this->tentative_max_score = - INT_MAX;	
	this->setSearchTarget(field, agent);
	
	std::for_each(this->search_target.begin(), this->search_target.end(), [&, this](auto& coord){
			this->multiThread(field, agent, coord);
			if(this->is_time_over)
				return;
		});
	
	if(this->is_time_over)
		return;
	
	std::chrono::system_clock::time_point end = std::chrono::system_clock::now();
	double time = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
	std::cout << time << "milliseconds" << std::endl;

	if(this->tentative_max_score == -INT_MAX)
		return;

	this->decided_route.at(agent) = this->tentative_route;
	this->decided_goal.at(agent)  = this->tentative_goal;
	this->setDecidedCoord(this->tentative_route);
	this->current_score.at(agent) = this->tentative_max_score;
	
	this->printRoute(this->tentative_route);
	this->counter.at(agent) = 0;

	/*
	std::vector<std::thread> threads;
	std::chrono::system_clock::time_point  start, end;
	double time;
	tentative_max_score = - INT_MAX;
	start = std::chrono::system_clock::now();
	this->setSearchTarget(field, agent);
	std::for_each(this->search_target.begin(), this->search_target.end(), [&, this](auto& coord){
			threads.emplace_back(std::thread(&Astar::multiThread, this, std::ref(field), agent, std::ref(coord)));
		});
	for(auto& thread : threads)
		thread.join();
	end = std::chrono::system_clock::now();
	time = std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count();
	std::cout << time << "milliseconds" << std::endl;
	if(this->tentative_max_score == -INT_MAX){
		this->decided_route.at(agent).clear();
		return;
	}
	this->decided_route.at(agent) = this->tentative_route;
	this->decided_goal.at(agent)  = this->tentative_goal;
	this->setDecidedCoord(this->tentative_route);
	this->printRoute(this->tentative_route);
	this->counter.at(agent) = 0;
	*/
}

void 	Astar::search(Field& field, const uint_fast32_t attr){
	this->init(field);
	for(size_t i = 0; i < field.agents.size(); i++)
		if(field.agents.at(i).getAttr() == attr)
			this->searchBestRoute(field, i);
}

const std::vector<std::pair<uint_fast32_t, uint_fast32_t>> Astar::makeRoute(Field& field, std::vector<Node>& node, const uint_fast32_t agent, const std::pair<uint_fast32_t, uint_fast32_t>& goal){
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route;
	std::pair<uint_fast32_t, uint_fast32_t> from;

	route.push_back(goal);
	from = node.at(goal.second * field.getWidth() + goal.first).parent->coord;
	route.emplace_back(from);

	while(true){
		if(node.at(from.second * field.getWidth() + from.first).parent == nullptr)
			break;
		from = node.at(from.second * field.getWidth() + from.first).parent->coord;
	  route.emplace_back(from);
	}
	
	std::reverse(route.begin(), route.end());
	return route;
}

void Astar::setDecidedCoord(const std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route){
	std::for_each(route.begin(), route.end(), [&, this](auto& coord){
			auto result = std::find(this->decided_coord.begin(), this->decided_coord.end(), coord);
			if(result == this->decided_coord.end())
				this->decided_coord.emplace_back(coord);
		});
}

const void Astar::printGoal(Field& field, const uint_fast32_t attr) const{
	glPointSize(point_size - 10);
	glColor3f(0.0f, 0.0f, 1.0f);
	glBegin(GL_POINTS);
	for(size_t i = 0; i < this->decided_goal.size(); i++){
		if(field.agents.at(i).getAttr() == attr){
			glVertex2i(half + cell_size * this->decided_goal.at(i).first, half + cell_size * this->decided_goal.at(i).second);
		}
	}
	glEnd();
	glFlush();
}

const void Astar::printRoute(std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route){	
	glPointSize(point_size);
	glColor3f(0.0f, 0.0f, 0.0f);
	glBegin(GL_POINTS);
	std::for_each(route.begin(), route.end(), [&, this](auto& coord){
			glVertex2i(half + cell_size * coord.first, half + cell_size * coord.second);
		});
	glEnd();
	glFlush();
}

void Astar::chooseAlgorithm(Field& field, const uint_fast32_t agent){
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
		
	//全探索
	if(field.getTurn() >= field.getMaxTurn() - beam_depth){
		Direction direction = this->finalPhase(field, agent);
		
		field.agents.at(agent).move(direction);
		this->next_coord.push_back(std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
		this->decided_route.at(agent) = std::vector<std::pair<uint_fast32_t, uint_fast32_t>>();
		return;
	}

	//敵Agentが接近している場合
	if(this->countAdjacentAgent(field, agent, ENEMY_ATTR) == 2){
		this->decided_route.at(agent) = std::vector<std::pair<uint_fast32_t, uint_fast32_t>>();
		this->singleMove(field, agent);
		return;
	}

	//味方Agentが接近している場合
	if(this->countAdjacentAgent(field, agent, MINE_ATTR) == 1){
		this->decided_route.at(agent) = std::vector<std::pair<uint_fast32_t, uint_fast32_t>>();
		this->singleMove(field, agent);
		return;
	}

	//時間処理
	if(this->is_time_over){
		Direction direction = this->exceptionMove(field, agent);
		
		field.agents.at(agent).move(direction);
		this->next_coord.push_back(std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
		this->decided_route.at(agent) = std::vector<std::pair<uint_fast32_t, uint_fast32_t>>();
		return;
	}
	
	this->singleMove(field, agent);
}

void Astar::singleMove(Field& field, const uint_fast32_t agent){
	Direction direction;
	const uint_fast32_t x = field.agents.at(agent).getX();
	const uint_fast32_t y = field.agents.at(agent).getY();
	
	if(this->decided_route.at(agent).size() <= 1 || this->counter.at(agent) == search_count)
		this->searchBestRoute(field, agent);
	else
		this->correctionRoute(field, agent);

	if(this->is_time_over)
		goto _EXCEPTION_SEARCH;

	if(this->decided_route.at(agent).empty())
		goto _EXCEPTION_SEARCH;
	
	if(this->decided_route.at(agent).at(0).first == x && this->decided_route.at(agent).at(0).second == y)
		this->decided_route.at(agent).erase(this->decided_route.at(agent).begin());

	if(this->decided_route.at(agent).empty())
		goto _EXCEPTION_SEARCH;

	{
	auto result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(this->decided_route.at(agent).at(0).first, this->decided_route.at(agent).at(0).second));
	if(result != this->next_coord.end()){
		goto _EXCEPTION_SEARCH;
	}

	
	/*
	if(result != this->next_coord.end()){
		this->searchBestRoute(field, agent);
		if(this->is_time_over)
			goto _EXCEPTION_SEARCH;

		if(this->decided_route.at(agent).empty())
			goto _EXCEPTION_SEARCH;
	
		if(this->decided_route.at(agent).at(0).first == x && this->decided_route.at(agent).at(0).second == y)
			this->decided_route.at(agent).erase(this->decided_route.at(agent).begin());

		if(this->decided_route.at(agent).empty())
			goto _EXCEPTION_SEARCH;
	}
	result = std::find(this->next_coord.begin(), this->next_coord.end(), std::make_pair(this->decided_route.at(agent).at(0).first, this->decided_route.at(agent).at(0).second));
	if(result != this->next_coord.end())
		goto _EXCEPTION_SEARCH;
	*/

	
	}
	
	this->next_coord.push_back(std::make_pair(this->decided_route.at(agent).at(0).first, this->decided_route.at(agent).at(0).second));
	
	direction = this->changeDirection(std::make_pair(x, y), std::make_pair(this->decided_route.at(agent).at(0).first, this->decided_route.at(agent).at(0).second));
	if(field.canMove(field.agents.at(agent), direction)){
		field.agents.at(agent).move(direction);
		this->counter.at(agent)++;
		return;
	}

 _EXCEPTION_SEARCH:
	direction = this->exceptionMove(field, agent);
	field.agents.at(agent).move(direction);
	this->next_coord.push_back(std::make_pair(x + this->vec_x.at(direction), y + this->vec_y.at(direction)));
	this->decided_route.at(agent) = std::vector<std::pair<uint_fast32_t, uint_fast32_t>>();
}

void Astar::correctionRoute(Field& field, const uint_fast32_t agent){
	std::pair<int_fast32_t, std::vector<Node>> condidate;
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> route;
	int_fast32_t score;
	
	condidate = this->searchRoute(field, agent, this->decided_goal.at(agent), this->decided_route.at(agent).size() + 3);
	score     = condidate.first;
	if(score > 0){
		route = this->makeRoute(field, condidate.second, agent, this->decided_goal.at(agent));
		this->decided_route.at(agent) = route;
		this->setDecidedCoord(route);
		this->current_score.at(agent) = score;
		this->setDecidedCoord(this->tentative_route);
		this->printRoute(route);
	}
}

void Astar::init(const Field* field){
	this->setAverageScore(*field);
	std::cout << "average_score:" << this->average_score << std::endl;
	
	this->decided_route.clear();
	this->decided_route.resize(field->agents.size());
	this->decided_goal.clear();
	this->decided_goal.resize(field->agents.size());
	this->decided_coord.clear();
	
	this->counter.clear();
	this->counter.resize(field->agents.size());
	
	this->current_score.clear();
	this->current_score.resize(field->agents.size());
}

void Astar::init(const Field& field){
	this->setAverageScore(field);
	std::cout << "average_score:" << this->average_score << std::endl;
		
	this->decided_route.clear();
	this->decided_route.resize(field.agents.size());
	this->decided_goal.clear();
	this->decided_goal.resize(field.agents.size());
	this->decided_coord.clear();

	this->counter.clear();
	this->counter.resize(field.agents.size());
	
	this->current_score.clear();
	this->current_score.resize(field.agents.size());
}

void Astar::move(Field *field, const uint_fast32_t attr){
	this->clock = std::chrono::system_clock::now();
	this->is_time_over = false;
	Field tmp = static_cast<Field> (*field);
	
	this->decided_coord.clear();
	this->next_coord.clear();
	
	for(size_t i = 0; i < tmp.agents.size(); i++)
		if(tmp.agents.at(i).getAttr() == attr)
			this->chooseAlgorithm(tmp, i);
	*field = tmp;
}

int_fast32_t expectedScore(Astar* astar, Field field, const uint_fast32_t agent){
	Astar tmp = *astar;
	
	if(field.agents.at(agent).getAttr() == MINE_ATTR)
		return field.calcScore(MINE_ATTR) - field.calcScore(ENEMY_ATTR);
	else
		return field.calcScore(ENEMY_ATTR) - field.calcScore(MINE_ATTR);
}

/src/disp.cpp
#include"disp.hpp"

// ---------------------------------------- Print ----------------------------------------
Print::Print(){	
}

Print::~Print(){
}

void Print::renderString(float x, float y, const std::string& str) const{
	float z = 0.0f;
	glRasterPos3f(x, y, z);
	for(size_t i = 0; i < (int_fast32_t)str.size(); ++i){
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, str[i]);
	}
}

void Print::line(const Field* field) const{
	glColor3f(0.0f, 0.0f, 0.0f);
	glLineWidth(line_size);
	glBegin(GL_LINES);
	for(size_t i = 0; i <= field->getWidth(); i++){
		glVertex2i(cell_size * i, 0);
		glVertex2i(cell_size * i, cell_size * field->getHeight());
	}
	for(size_t j = 0; j <= field->getHeight(); j++){
		glVertex2i(0, cell_size * j);
		glVertex2i(cell_size * field->getWidth(), cell_size * j);
	}
	glEnd();
}

void Print::score(const Field* field) const{
	int_fast32_t value = 0;
	glColor3f(0.0f, 0.0f, 0.0f);
	for(size_t j = 0; j < field->getHeight(); j++){
			for(size_t i = 0; i < field->getWidth(); i++){
			value = field->at(i, j)->getValue();
			std::string str = std::to_string(value);
			this->renderString(i * cell_size + 5, (j + 1) * cell_size - 5, str);
		}
	}
}

void Print::panel(const Field* field) const{
	const int_fast32_t half = cell_size / 2;
	glPointSize(agent_size);
	glBegin(GL_POINTS);
	for(size_t j = 0; j < field->getHeight(); j++){
		for(size_t i = 0; i < field->getWidth(); i++){
			if(field->at(i, j)->isPurePanel())
				continue;
			if(field->at(i, j)->isMyPanel())
				glColor3f(0.6f, 0.6f, 1.0f);
			if(field->at(i, j)->isEnemyPanel())
				glColor3f(1.0f, 0.6f, 0.6f);
			glVertex2i(half + cell_size * i, half + cell_size * j);
		}
	}
	glEnd();
}

void Print::agent(Field* field) const{
	const uint_fast32_t half = cell_size / 2;
	uint_fast32_t flag;
	glPointSize(agent_size);
	glBegin(GL_POINTS);
	std::for_each(field->agents.begin(), field->agents.end(), [&, this](auto& a){
			flag = a.getAttr();
			if(flag == MINE_ATTR)
				glColor3f(0.0f, 0.0f, 0.8f);
			if(flag == ENEMY_ATTR)
				glColor3f(0.8f, 0.0f, 0.0f);
			glVertex2i(half+cell_size * a.getX(), half + cell_size * a.getY());
		});
	glEnd();
}

void Print::agentNum(Field* field) const{
	const uint_fast32_t half = cell_size / 2;
	uint_fast32_t flag, mine = 0, enemy = 0;
	std::string value, str;
	glColor3f(0.0f, 0.0f, 0.0f);
	std::for_each(field->agents.begin(), field->agents.end(), [&, this](auto& a){
			flag = a.getAttr();
			if(flag == MINE_ATTR){
				mine++;
				value = std::to_string(mine);
				str = "M" + value;
				this->renderString(half + cell_size * a.getX() - 2, half + cell_size * a.getY(), str);
			}
			if(flag == ENEMY_ATTR){
				enemy++;
				value = std::to_string(enemy);
				str = "E" + value;
				this->renderString(half + cell_size * a.getX() - 2, half+cell_size * a.getY(), str);
			}
		});
}

void Print::point(const Field* field) const{
	;
}

void Print::candidate(Field* field, const std::vector<Direction>& next) const{
	const uint_fast32_t half = cell_size / 2;
	Direction direction;
	uint_fast32_t coordX, coordY;
	glPointSize(agent_size - 8);
	glColor3f(1.0f, 1.0f, 0.0f);
	glBegin(GL_POINTS);
	for(size_t i = 0; i < next.size(); i++){
		if(field->agents.at(i).getAttr() == MINE_ATTR){
			direction = next.at(i);
			coordX = field->agents.at(i).getX() + vec_x.at((int_fast32_t)direction);
			coordY = field->agents.at(i).getY() + vec_y.at((int_fast32_t)direction);
			glVertex2i(half + cell_size * coordX, half + cell_size * coordY);
		}
	}
	glEnd();

	
	/*
	const uint_fast32_t half = cell_size / 2;
	Direction direction;
	uint_fast32_t coordX, coordY;
	glPointSize(agent_size - 8);
	glColor3f(1.0f, 1.0f, 0.0f);
	glBegin(GL_POINTS);
	for(size_t i = 0; i < next.size(); i++){
		direction = next.at(i);
		coordX = field->agents.at(i).getX() + vec_x.at((int_fast32_t)direction);
		coordY = field->agents.at(i).getY() + vec_y.at((int_fast32_t)direction);
		glVertex2i(half + cell_size * coordX, half + cell_size * coordY);
	}
	glEnd();
	*/
}

PrintDisplay::PrintDisplay(){
}

PrintDisplay::~PrintDisplay(){	
}

void PrintDisplay::print(Field* field, const std::vector<Direction> next){
	this->line(field);
	this->panel(field);
	this->agent(field);
	this->candidate(field, next);
	this->agentNum(field);
	this->score(field);
	this->point(field);
}

void PrintDisplay::print(Field* field){
	;
}

PrintSelfDirectedGame::PrintSelfDirectedGame(){
}

PrintSelfDirectedGame::~PrintSelfDirectedGame(){
}

void PrintSelfDirectedGame::print(Field* field, const std::vector<Direction> next){
	;
}

void PrintSelfDirectedGame::print(Field* field){
	this->line(field);
	this->panel(field);
	this->agent(field);
	this->agentNum(field);
	this->score(field);
	this->point(field);
}

// ---------------------------------------- DisplayWrapper ----------------------------------------

DisplayWrapper::DisplayWrapper(){
	this->random               = new Random();
	this->astar                = new Astar();
	this->greedy               = new Greedy();
	
	this->beam_search          = new BeamSearch();
	this->breadth_force_search = new BreadthForceSearch();
}

DisplayWrapper::~DisplayWrapper(){
	delete this->instance;
	delete this->field;
	delete this->print;
	
	delete this->random;
	delete this->astar;
	delete this->greedy;

	delete this->beam_search;
	delete this->breadth_force_search;
}

DisplayWrapper* DisplayWrapper::instance = 0;

void DisplayWrapper::init(){
	this->instance->initInstance();
	this->astar->init(this->field);
	gluOrtho2D(0, 100, 100, 0);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGBA|GLUT_DOUBLE);
	glutInitWindowPosition(window_width_position, window_height_position);
	glutInitWindowSize(window_width_size, window_height_size);
	glClearColor(1.0, 1.0, 1.0, 1.0);
}

void DisplayWrapper::start(int argc, char *argv[]){
	glutInit(&argc, argv);
  glutCreateWindow("procon2019");
	init();
	glutDisplayFunc(displayWrapper);
	glutKeyboardFunc(keyboardWrapper);
	glutReshapeFunc(resizeWrapper);
	glutMouseFunc(mouseWrapper);
	glFlush();
	glutMainLoop();
}

void DisplayWrapper::resizeWrapper(int w, int h){
	instance->resize(w,h);
}

void DisplayWrapper::displayWrapper(){
	instance->display();
}

void DisplayWrapper::keyboardWrapper(unsigned char key, int x, int y){
	instance->keyboard(key, x, y);
}

void DisplayWrapper::specialKeyboardWrapper(int key, int x, int y){
	instance->specialKeyboard(key, x, y);	
}

void DisplayWrapper::mouseWrapper(int button, int state, int x, int y){
	instance->mouse(button, state, x, y);
}

void DisplayWrapper::motionWrapper(int x, int y){
	instance->motion(x, y);
}

void DisplayWrapper::setInstance(DisplayWrapper* framework){
	instance = framework;
}


void DisplayWrapper::setField(Field* object){
	field = object;
}

// ---------------------------------------- Display ----------------------------------------
Display::Display() : mine_flag(0) {
	this->print = new PrintDisplay();
}

Display::~Display(){
}


/*

Display::Display() : agent_flag(0), mine_flag(0), enemy_flag(0) {
	this->print = new PrintDisplay();
}

void Display::setPossible(){
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> coord, buf;
	uint_fast32_t x, y;
	this->possible.clear();
	for(size_t i = 0; i < DIRECTION_SIZE - 1; i++)
		coord.push_back(std::make_pair(vec_x.at(i), vec_y.at(i)));
	std::for_each(this->field->agents.begin(), this->field->agents.end(), [&, this](auto& a){
			std::for_each(coord.begin(), coord.end(), [&, this](auto& c){
					x = a.getX() + c.first;
					y = a.getY() + c.second;	
					if(this->isOutOfRange(GLUT_LEFT_BUTTON, GLUT_DOWN, x, y))
						return;
					buf.push_back(std::make_pair(x, y));
				});
			this->possible.push_back(buf);
			buf.clear();
		});
	this->init();
}

void Display::moveNext(){
	uint_fast32_t count = 0;
	std::for_each(this->field->agents.begin(), this->field->agents.end(), [&, this](auto& a){
			if(this->next.at(count) == NONE)
				goto RE_CONSIDER;
			if(this->field->canMove(a, this->next.at(count)))
				a.move(this->next.at(count));
			else
				a.move(STOP);
		RE_CONSIDER:			
			count++;
		});
	this->field->applyNextAgents();
}

void Display::selectAgent(uint_fast32_t x, uint_fast32_t y){
	for(size_t i = 0; i < this->field->agents.size(); i++){
		if(this->field->agents.at(i).getX() == x && this->field->agents.at(i).getY() == y){
			if(this->field->agents.at(i).getAttr() == ENEMY_ATTR){
				this->agent_flag = 1;
				this->enemy_flag = i;
			}
			if(this->field->agents.at(i).getAttr() == MINE_ATTR){
				this->agent_flag = 0;
				this->mine_flag = i;
			}
			return;
		}
	}
}

void Display::selectDirection(uint_fast32_t x, uint_fast32_t y){
	std::pair<uint_fast32_t, uint_fast32_t> coord = std::make_pair(x, y);
	if(this->agent_flag){
		for(size_t i = 0; i < this->possible.at(this->enemy_flag).size(); i++){
			if(this->possible.at(this->enemy_flag).at(i) == coord){
				this->next.at(this->enemy_flag) = (Direction)i;
				glutPostRedisplay();
				return;
			}
		}
	}
	else{
		for(size_t i = 0; i < this->possible.at(this->mine_flag).size(); i++){
			if(this->possible.at(this->mine_flag).at(i) == coord){
				this->next.at(this->mine_flag) = (Direction)i;
				glutPostRedisplay();				
				return;
			}
		}
	}
}
*/


void Display::setPossible(){
	std::vector<std::pair<uint_fast32_t, uint_fast32_t>> direction, tmp;
	uint_fast32_t x, y;
	
	this->possible.clear();
	this->possible.resize(this->field->agents.size());
	
	for(size_t i = 0; i < DIRECTION_SIZE - 1; i++)
		direction.push_back(std::make_pair(vec_x.at(i), vec_y.at(i)));
	
	for(size_t i = 0; i < this->field->agents.size(); i++){
		if(this->field->agents.at(i).getAttr() == MINE_ATTR){
			std::for_each(direction.begin(), direction.end(), [&, this](auto& d){
					x = this->field->agents.at(i).getX() + d.first;
					y = this->field->agents.at(i).getY() + d.second;
					if(this->isOutOfRange(GLUT_LEFT_BUTTON, GLUT_DOWN, x, y))
						return;
					tmp.push_back(std::make_pair(x, y));
				});
			this->possible.at(i) = tmp;
			tmp.clear();
		}
	}
	
	this->init();
}

void Display::moveNext(){
	for(size_t i = 0; i < this->field->agents.size(); i++){
		if(this->field->agents.at(i).getAttr() == MINE_ATTR){
			if(this->next.at(i) == NONE)
				this->field->agents.at(i).move(STOP);
			if(this->field->canMove(this->field->agents.at(i), this->next.at(i)))
				this->field->agents.at(i).move(this->next.at(i));
		}
	}
}

bool Display::selectAgent(uint_fast32_t x, uint_fast32_t y){
	for(size_t i = 0; i < this->field->agents.size(); i++){
		if(this->field->agents.at(i).getAttr() == MINE_ATTR){
			if(this->field->agents.at(i).getX() == x && this->field->agents.at(i).getY() == y){
				this->mine_flag = i;
				this->next.at(this->mine_flag) = STOP;
				glutPostRedisplay();
				return true;
			}
		}
	}
	return false;
}

void Display::selectDirection(uint_fast32_t x, uint_fast32_t y){
	Direction direction = STOP;
	uint_fast32_t agentX = this->field->agents.at(this->mine_flag).getX();
	uint_fast32_t agentY = this->field->agents.at(this->mine_flag).getY();
	std::pair<uint_fast32_t, uint_fast32_t> coord = std::make_pair(x, y);
	
	for(size_t i = 0; i < this->possible.at(this->mine_flag).size(); i++){
		if(this->possible.at(this->mine_flag).at(i) == coord){
			direction = this->changeDirection(std::make_pair(agentX, agentY), std::make_pair(x, y));
			this->next.at(this->mine_flag) = direction;
			glutPostRedisplay();
			return;
		}
	}
}

void Display::init(){
	std::fill(this->next.begin(), this->next.end(), STOP);
	this->mine_flag = 0;
	
	//this->agent_flag = 0;	
	//this->enemy_flag = 0;
}

const bool Display::isOutOfRange(int button, int state, int x, int y) const{
	const bool launch = (button == GLUT_LEFT_BUTTON && state==GLUT_DOWN);
	const bool range = (x < 0 || x > cell_size * this->field->width || y < 0 || y > cell_size * this->field->height);
	if(!launch || range)
		return true;
	return false;
}

void Display::initInstance(){
	this->next.clear();
	this->next.resize(this->field->agents.size());
	std::fill(this->next.begin(), this->next.end(), STOP);
	this->setPossible();
}

void Display::resize(int w, int h){
	glViewport(0, 0, w, h);
	glLoadIdentity();
	glOrtho(-0.5, (GLdouble)w - 0.5, (GLdouble)h - 0.5, -0.5, -1.0, 1.0);
}
	
void Display::display(){
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	this->print->print(this->field, next);
	glFlush();
}

void Display::keyboard(unsigned char key, int x, int y){
	switch(key){
	case 'q':
	case 'Q':
	case '\033':

		std::exit(0);
		break;
		
	case 'w':
	case 'W':

		this->greedy->move(this->field, MINE_ATTR);
		this->greedy->move(this->field, ENEMY_ATTR);
		break;
		
	case 'm':
	case 'M':

		this->random->move(this->field, MINE_ATTR);
		this->random->move(this->field, ENEMY_ATTR);
		break;
		
	case 'g':
	case 'G':
		
		this->moveNext();
		this->random->move(this->field, ENEMY_ATTR);
		break;

	case 't':
	case 'T':

		this->astar->move(this->field, MINE_ATTR);
		//this->astar->move(this->field, ENEMY_ATTR);

		//this->greedy->move(this->field, MINE_ATTR);
		this->greedy->move(this->field, ENEMY_ATTR);

		//this->beam_search->move(this->field, MINE_ATTR);
		//this->beam_search->move(this->field, ENEMY_ATTR);
		
		//this->random->move(this->field, ENEMY_ATTR);
		//this->random->move(this->field, MINE_ATTR);
		break;

	case 'b':
	case 'B':

		//this->breadth_force_search->move(this->field, MINE_ATTR);
		//this->breadth_force_search.move(this->field, ENEMY_ATTR);
		
		this->beam_search->move(this->field, MINE_ATTR);
		//this->beam_search->move(this->field, ENEMY_ATTR);
		
		this->random->move(this->field, ENEMY_ATTR);
		//this->random->move(this->field, MINE_ATTR);
		break;
		
	case 'd':
	case 'D':
		
		this->greedy->move(this->field, MINE_ATTR);
		//this->greedy->move(this->field, ENEMY_ATTR);

		this->random->move(this->field, ENEMY_ATTR);
		//this->random->move(this->field, MINE_ATTR);
		break;

	default:
		break;
	}
	
	this->field->applyNextAgents();
	this->setPossible();
	this->field->print();
	glutPostRedisplay();

	if(field->checkEnd()){
		field->judgeWinner();
		std::this_thread::sleep_for(std::chrono::minutes(1));
		std::exit(0);
	}
}

void Display::specialKeyboard(int key, int x, int y){
	;
}

void Display::mouse(int button, int state, int x, int y){
	if(this->isOutOfRange(button, state, x, y))
		return;
	const uint_fast32_t coordX = x / cell_size;
	const uint_fast32_t coordY = y / cell_size;
	if(this->selectAgent(coordX, coordY))
		return;
	this->selectDirection(coordX, coordY);
}

void Display::motion(int x, int y){
	;
}

selfDirectedGame::selfDirectedGame(){
	this->print = new PrintSelfDirectedGame();
}

selfDirectedGame::~selfDirectedGame(){
}

void selfDirectedGame::resize(int w, int h){
	;
}

void selfDirectedGame::display(){
	;
}

void selfDirectedGame::keyboard(unsigned char key, int x, int y){
	;
}

void selfDirectedGame::specialKeyboard(int key, int x, int y){
	;
}

void selfDirectedGame::mouse(int button, int state, int x, int y){
	;
}

void selfDirectedGame::motion(int x, int y){
	;
}


/src/evaluator.cpp
#include "evaluator.hpp"

/src/field.cpp
#include "field.hpp"
#include <fstream>
#include <cassert>

using namespace picojson;

// ---------------------------------------- Panel ----------------------------------------

Panel::Panel():value(0) {
	setPure();
}

Panel::Panel(int_fast32_t value):value(value) {
	setPure();
}

void Panel::setValue(int_fast32_t value) {
	this->value = value;
}

bool Panel::isMyPanel() const {
	return this->attr & MINE_ATTR;
}

bool Panel::isEnemyPanel() const {
	return this->attr & ENEMY_ATTR;
}

bool Panel::isPurePanel() const {
	return !this->attr;
}

uint_fast32_t Panel::getAttr() const {
	return this->attr;
}

void Panel::setMine() {
	this->attr = MINE_ATTR;
}

void Panel::setEnemy() {
	this->attr = ENEMY_ATTR;
}

void Panel::setPure() {
	this->attr = PURE_ATTR;
}

int_fast32_t Panel::getValue() const {
	return this->value;
}

// ---------------------------------------- Field ---------------------------------------------
Field::Field(uint_fast32_t width, uint_fast32_t height):width(width),height(height),turn(0) {
	double buf;
	uint_fast32_t size;

	this->random = XorOshiro128p(time(NULL));

	buf = std::log2(this->width);
	this->yShiftOffset = (uint_fast32_t)(buf + ((std::ceil(buf) == std::floor(buf)) ? 0 : 1));
	size = this->height << this->yShiftOffset;

	// マップ生成
	this->field = std::vector<Panel>(size, Panel(0));

	genRandMap();

	// とりあえずAgentを適当に生成
	this->agents.emplace_back(1, 1, MINE_ATTR);
	this->agents.emplace_back(width - 3, 2, MINE_ATTR);
	this->agents.emplace_back(2, height - 3, MINE_ATTR);
	this->agents.emplace_back(width - 2, height - 2, MINE_ATTR);

	this->agents.emplace_back(2, 2, ENEMY_ATTR);
	this->agents.emplace_back(width - 2, 1, ENEMY_ATTR);
	this->agents.emplace_back(1, height - 2, ENEMY_ATTR);
	this->agents.emplace_back(width - 3, height - 3, ENEMY_ATTR);

	this->canmoveAgents = std::vector<bool>(this->agents.size(), true);

	// エージェントの初期位置のパネルの属性を設定
	for(auto &i: this->agents) {
		setPanelAttr(i.getX(), i.getY(), i.getAttr());
	}

	//とりあえずSTOPにセット
	std::for_each(this->agents.begin(), this->agents.end(), [&, this](auto& a){
			a.move(STOP);
		});

	this->max_turn = 70;

}

Field::Field() {
}

uint_fast32_t Field::xyIndex(uint_fast32_t x, uint_fast32_t y) {
	return x + (y << this->yShiftOffset);
}

void Field::setPanelScore(uint_fast32_t x, uint_fast32_t y, int_fast32_t value) {
	this->field[x + (y << this->yShiftOffset)].setValue(value);
}

void Field::setPanelAttr(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr) {
	switch(attr) {
	case MINE_ATTR:
		this->field[x + (y << this->yShiftOffset)].setMine();
		break;
	case ENEMY_ATTR:
		this->field[x + (y << this->yShiftOffset)].setEnemy();
		break;
	case PURE_ATTR:
		this->field[x + (y << this->yShiftOffset)].setPure();
		break;
	default:
		fprintf(stderr, "Attr %x は存在しません。\n", attr);
		break;
	}
}

void Field::genRandMap(){
	static const int m = 30;
  static const double s = 7.0;
  static const double slide = 25;
  static const double pi = 3.1415926535;

  double x,y;
  double r1,r2;

	int N = 32;
	std::vector<int> field_rand;
  std::vector<int> field_rev;
  std::vector<int> buf;
	int buf_height, buf_width;
  int field_rand_sum = -1; // <- Debug



	buf_height=(this->height/2)+(this->height%2);
	buf_width=(this->width/2)+(this->width%2);

  // fix bug(for even) -----------------------
  // Add while loop
  // ----- INFO ------------------------------
  // (field_rand_sum < m)||(field_rand_sum >= n)
  //
  // field_rand_sum == m + 4
  //
  // if n == m+4
  // field_rand_sum == m
  // -----------------------------------------
  while(field_rand_sum < 0){
    field_rand.clear(); // <- Debug
    field_rev.clear();  // <- Debug
    field_rand_sum = 0; // <- Debug
    for(int i=0; i < buf_height; i++){
      for(int j=0; j < buf_width; j++){
        r2 = this->random(INT_MAX) / 2147483647.1;
        r1 =this->random(INT_MAX)  / 2147483647.1;
        x = s * sqrt(-2 * log(r1)) * cos(2 * pi * r2)+m-slide;
				if((int)x > 16)
					x = 16;
				if((int)x < -16)
					x = -16;
        buf.push_back((int)x);
        //buf.push_back((rand() % N)-16);
      }

      field_rand.insert(field_rand.end(), buf.begin(), buf.end());
      std::reverse(buf.begin(), buf.end());
      field_rand.insert(field_rand.end(), buf.begin(), buf.end());
      buf.clear();
    }

    field_rev = field_rand;
    std::reverse(field_rev.begin(), field_rev.end());
    field_rand.insert(field_rand.begin(), field_rev.begin(), field_rev.end());

    field_rand_sum = std::accumulate(field_rand.begin(),field_rand.end(),0);  // <- Debug
  }
  // showing field_sum pt ---------------------------------
  std::cerr << "[*]field_sum:" << field_rand_sum << std::endl;

	//奇数業に対応させる

	if(this->height%2){
		field_rand.erase(field_rand.begin()+(field_rand.size()/2), field_rand.begin()+(field_rand.size()/2)+this->height+1);
	}
	if(this->width%2){
		for(int i=0;i<field_rand.size();i++){
			if(i%this->width==this->width/2)
				field_rand.erase(field_rand.begin()+i);
		}
	}

	int val=0;

	for(int i=0;i<this->height;i++){
		for(int j=0;j<this->width;j++){
			this->setPanelScore(j, i, field_rand.at(val));
			val++;
		}
	}
}

bool Field::canMove(Agent &agent, Direction direction) {
	int_fast32_t nextX = agent.getX() + direction2x(direction), nextY = agent.getY() + direction2y(direction);

	if(nextX < 0 || nextX > this->width - 1 || nextY < 0 || nextY > this->height - 1) return false;

	return true;
}

void Field::applyNextAgents() {
	// ||agents||が小さいため愚直な実装でも問題なさそう
	// TODO:早くできるいい方法があるなら実装すべき
	for(size_t i = 0; i < this->agents.size(); i++) {
		for(size_t j = 0; j < this->agents.size(); j++) {
			if(i == j || this->agents[i].getnextX() != this->agents[j].getnextX() ||  this->agents[i].getnextY() != this->agents[j].getnextY()) continue;
			this->canmoveAgents[i] = false;
			this->canmoveAgents[j] = false;
			this->agents[i].move(STOP);
			this->agents[j].move(STOP);
		}
	}

	for(size_t i = 0; i < this->agents.size(); i++) {
		if(this->canmoveAgents[i]) {
			if(!this->at(this->agents[i].getnextX(), this->agents[i].getnextY())->isPurePanel() && this->at(this->agents[i].getnextX(), this->agents[i].getnextY())->getAttr() != this->agents[i].getAttr()) {
				setPanelAttr(this->agents[i].getnextX(), this->agents[i].getnextY(), PURE_ATTR);
			} else {
				this->agents[i].setNext();
				setPanelAttr(this->agents[i].getX(), this->agents[i].getY(), this->agents[i].getAttr());
			}
		} else {
			this->canmoveAgents[i] = true;
		}
	}

	//とりあえずSTOPにセット
	std::for_each(this->agents.begin(), this->agents.end(), [&, this](auto& a){
			a.setnextbufXY(a.getnextX(), a.getnextY());
			a.move(STOP);
		});


	//ターンを刻む
	this->turn++;
}

UF Field::makePureTreeMine() {
    UF pureTree(field.size());

    for(int i=0; i<height; i++) {
        for(int j=0; j<width; j++) {
            if(!this->at(j,i)->isPurePanel() && !this->at(j,i)->isEnemyPanel()) continue;
    		    // UP
                if(i-1 >= 0) {
                        if(this->at(j, i-1)->isPurePanel() || this->at(j, i-1)->isEnemyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j,i-1));
                        }
                }
                // DOWN
                if(i+1 < height) {
                        if(this->at(j, i+1)->isPurePanel() || this->at(j, i+1)->isEnemyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j,i+1));
                        }
                }
                // RIGHT
                if(j+1 < width) {
                        if(this->at(j+1, i)->isPurePanel() || this->at(j+1, i)->isEnemyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j+1, i));
                        }
                }
                // LEFT
                if(j-1 >= 0) {
                        if(this->at(j-1, i)->isPurePanel()  || this->at(j-1, i)->isEnemyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j-1, i));
                        }
                }
		}
	}
	return pureTree;
}

UF Field::makePureTreeEnemy() {
    UF pureTree(field.size());

    for(int i=0; i<height; i++) {
        for(int j=0; j<width; j++) {
            if(!this->at(j,i)->isPurePanel() && !this->at(j,i)->isMyPanel()) continue;
    		    // UP
                if(i-1 >= 0) {
                        if(this->at(j, i-1)->isPurePanel() || this->at(j, i-1)->isMyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j,i-1));
                        }
                }
                // DOWN
                if(i+1 < height) {
                        if(this->at(j, i+1)->isPurePanel() || this->at(j, i+1)->isMyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j,i+1));
                        }
                }
                // RIGHT
                if(j+1 < width) {
                        if(this->at(j+1, i)->isPurePanel() || this->at(j+1, i)->isMyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j+1, i));
                        }
                }
                // LEFT
                if(j-1 >= 0) {
                        if(this->at(j-1, i)->isPurePanel()  || this->at(j-1, i)->isMyPanel()) {
                                pureTree.unite(xyIndex(j,i), xyIndex(j-1, i));
                        }
                }
		}
	}
	return pureTree;
}

std::unordered_map<int_fast32_t , std::vector<int_fast32_t>> Field::makePureTerritory(UF &&pureTree) {
	std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> retn;
	for(size_t i = 0; i < height; i++) {
		for(size_t j = 0; j < width; j++) {
			if(this->at(j, i)->isPurePanel()) retn[pureTree.root(xyIndex(j,i))].push_back(xyIndex(j, i));
		}
	}
	return retn;
}

int_fast32_t Field::calcMinepanelScore() {
	int_fast32_t tmpScore = 0;
	for(auto &i: field) {
		if(i.isMyPanel()) tmpScore += i.getValue();
	}
	return tmpScore;
}

int_fast32_t Field::calcEnemypanelScore() {
	int_fast32_t tmpScore = 0;
	for(auto &i: field) {
		if(i.isEnemyPanel()) tmpScore += i.getValue();
	}
	return tmpScore;
}

bool Field::isPanelMineBetween(uint_fast32_t x, uint_fast32_t y) {
	int_fast32_t buf = 0;
	// For over flow
	if(x == 0 || y == 0 || x == width - 1 || y == height - 1) return false;

	// left
	for(size_t i = x-1; i >= 0; i--) {
		if(this->at(i, y)->isMyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 0) return false;

	// right
	for(size_t i = x+1; i < width; i++) {
		if(this->at(i, y)->isMyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 1) return false;

	// up
	for(size_t i = y-1; i >= 0; i--) {
		if(this->at(x, i)->isMyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 2) return false;

	// down
	for(size_t i = y+1; i < height; i++) {
		if(this->at(x, i)->isMyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 3) return false;
	return true;
}

bool Field::isPanelEnemyBetween(uint_fast32_t x, uint_fast32_t y) {
	int_fast32_t buf = 0;
	
	// For over flow
	if(x == 0 || y == 0 || x == width - 1 || y == height - 1) return false;
	
	// left
	for(size_t i = x-1; i >= 0; i--) {
		if(this->at(i, y)->isEnemyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 0) return false;

	// right
	for(size_t i = x+1; i < width; i++) {
		if(this->at(i, y)->isEnemyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 1) return false;

	// up
	for(size_t i = y-1; i >= 0; i--) {
		if(this->at(x, i)->isEnemyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 2) return false;

	// down
	for(size_t i = y+1; i < height; i++) {
		if(this->at(x, i)->isEnemyPanel()) {
			buf++;
			break;
		}
	}
	if(buf == 3) return false;
	return true;
}

bool Field::checkLocalArea(uint_fast32_t x, uint_fast32_t y, uint_fast32_t attr) {
	if(attr == MINE_ATTR) return isPanelMineBetween(x, y);
	return isPanelEnemyBetween(x, y);
}

int_fast32_t Field::calcMineScore(std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> &pureTree) {
	int_fast32_t totalscore = 0, score;
	bool check, test;

	for(const auto &[key, vec]: pureTree) {
		check = true;
		score = 0;
		for(auto pn: vec) {
			test = checkLocalArea(indexX(pn), indexY(pn), MINE_ATTR);
			if(!checkLocalArea(indexX(pn), indexY(pn), MINE_ATTR)) {
				check = false;
				break;
			}
			score += std::abs(field.at(pn).getValue());
		}
		if(check == true) {
			totalscore += score;
		}
	}
	return totalscore;
}

const Panel *Field::at(uint_fast32_t x, uint_fast32_t y) const {
	return (const Panel *)&(this->field[x + (y << this->yShiftOffset)]);
}

int_fast32_t Field::calcEnemyScore(std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> &pureTree) {
	int_fast32_t totalscore = 0, score;
	bool check;

	for(const auto &[key, vec]: pureTree) {
		check = true;
		score = 0;
		for(auto pn: vec) {
			if(!checkLocalArea(indexX(pn), indexY(pn), ENEMY_ATTR)) {
				check = false;
				break;
			}
			score += std::abs(field.at(pn).getValue());
		}
		if(check == true) {
			totalscore += score;
		}
	}
	return totalscore;
}

int_fast32_t Field::calcScore(uint_fast32_t attr) {
	int_fast32_t score = 0;
	std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> pureTerritory;

	if(attr == MINE_ATTR) {
		score += calcMinepanelScore();
		pureTerritory = makePureTerritory(makePureTreeMine());
		score += calcMineScore(pureTerritory);
	} else {
		score += calcEnemypanelScore();
		pureTerritory = makePureTerritory(makePureTreeEnemy());
		score += calcEnemyScore(pureTerritory);
	}

	return score;
}

void Field::testMoveAgent() {
	Direction buf;
	for(auto &i: this->agents) {
RE_CONSIDER:
		buf = (Direction)this->random(DIRECTION_SIZE - 3);
		if(canMove(i, buf)) i.move(buf);
		else goto RE_CONSIDER; // もし動ける方向でなければ方向を検討し直す
	}

	applyNextAgents();
}


void Field::print() {
	uint_fast32_t flag;
	char strip[] = "----------------------------------------\n";

	fprintf(stderr, "%s", strip);
	for(size_t i = 0; i < this->height; i++) {
		for(size_t j = 0; j < this->width; j++) {
			// パネルの属性の表示処理
			if(this->at(j, i)->isMyPanel()) fprintf(stderr, "\x1b[34m");
			if(this->at(j, i)->isEnemyPanel()) fprintf(stderr, "\x1b[31m"); 
			// エージェントの表示処理
			// ||agents|| が十分に小さいため線形探索でも計算時間にそれほど影響がでない
			flag = PURE_ATTR;
			for(auto &a: this->agents) {
				if(a.getX() == j && a.getY() == i) {
					flag = a.getAttr();
					break;
				}
			}
			if(flag == MINE_ATTR) fprintf(stderr, "\x1b[34m");
			if(flag == ENEMY_ATTR) fprintf(stderr, "\x1b[31m");
			fprintf(stderr, "%3d ", this->at(j, i)->getValue());
			if(flag != PURE_ATTR) fprintf(stderr, "\x1b[39m");
			if(!this->at(j, i)->isPurePanel()) fprintf(stderr, "\x1b[39m");
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "%s", strip);
	for(size_t i = 0; i < this->agents.size(); i++) {
		if(this->agents[i].getAttr() == MINE_ATTR) fprintf(stderr, "\x1b[34m");
		else fprintf(stderr, "\x1b[31m");
		fprintf(stderr, "agent[%u]: (%u, %u)\n\x1b[39m", i, this->agents[i].getX(), this->agents[i].getY());
	}
	fprintf(stderr, "mineScore:  %d\n", this->calcScore(MINE_ATTR));
	fprintf(stderr, "enemyScore: %d\n", this->calcScore(ENEMY_ATTR));
	fprintf(stderr, "turn:       %d\n", this->turn);
	fprintf(stderr, "%s", strip);

}

const uint_fast32_t Field::getWidth() const{
	return this->width;
}

const uint_fast32_t Field::getHeight() const{
	return this->height;
}

const uint_fast32_t Field::getTurn() const{
	return this->turn;
}

const uint_fast32_t Field::getMaxTurn() const{
	return this->max_turn;
}

const bool Field::checkEnd() const{
	return (this->turn == (uint_fast32_t)this->max_turn);
}

void Field::judgeWinner(){
	fprintf(stderr, "\n---------------- finish ----------------\n");
	int_fast32_t mineScore = this->calcScore(MINE_ATTR);
	int_fast32_t enemyScore = this->calcScore(ENEMY_ATTR);

	printf("%d\n", mineScore - enemyScore);
	if(mineScore > enemyScore){
		printf("Win  MINE\n");
		printf("Lose ENEMY\n");
	} else if(mineScore == enemyScore){
		printf("Draw\n");
	} else if(mineScore < enemyScore){
		printf("Lose MINE\n");
		printf("Win  ENEMY\n");
	}
}

void Field::init(){
	// agetn情報
	int agent_data[30][3];
  
  int index_num = 0;     // ↑添字
	int agentid, x, y;
	int agent_num = 0;

  int my_attr_tmp; // TeamID用のjson添字
  int en_attr_tmp;

  int end_turn;    // 終了ターン数

	std::vector<int> map;
	std::vector<int> tile;
	double buffer;
	value maps;
	{
		std::fstream stream("./../../public_field/E-1.json");
		if(!stream.is_open()) return 1;
		stream >> maps;
		assert(get_last_error().empty());
		stream.close();
	}

  value matches;
  {
    std::fstream stream("./../../matches.json");
    if(!stream.is_open()) return 1;
    stream >> matches;
    assert(get_last_error().empty());
    stream.close();
  }


	this->height = (int)maps.get<object>()["height"].get<double>();
	this->width  = (int)maps.get<object>()["width"].get<double>();


	//------------------------------------------------------------------
	double buff;
	uint_fast32_t sizee;

	buff = std::log2(this->width);
	this->yShiftOffset = (uint_fast32_t)(buff + ((std::ceil(buff) == std::floor(buff)) ? 0 : 1));
	sizee = this->height << this->yShiftOffset;

	// マップ生成
	this->field = std::vector<Panel>(sizee, Panel(0));
  //------------------------------------------------------------------

	
	value::array points = maps.get<object>()["points"].get<value::array>();
	for(int i = 0; i < height; i++){
		value::array pt = points[i].get<value::array>();
		for(value item : pt){
			buffer = item.get<double>();
			map.push_back((int)buffer);
		}
	}
  

	value::array agents = maps.get<object>()["teams"].get<value::array>(); // all agent

	// teamID  <- 別のスクリプトで取ってくる必要あり
	int myID = (int)agents[0].get<object>()["teamID"].get<double>();
	int enID = (int)agents[1].get<object>()["teamID"].get<double>();
  // これ
  int myTeamID = (int)matches.get<object>()["teamID"].get<double>();

  if (myTeamID == myID){
    my_attr_tmp = 0;
    en_attr_tmp = 1;
  }else{
    my_attr_tmp = 1;
    en_attr_tmp = 0;
  }

	// agent array
	
	value::array myagents = agents[my_attr_tmp].get<object>()["agents"].get<value::array>(); // my
	value::array enagents = agents[en_attr_tmp].get<object>()["agents"].get<value::array>(); // enemy


  // Debug myTeamID -------------------------------------------------
  std::cout << "[*] myTeamID:" << myTeamID << std::endl;


	// Debug---------------
	std::cout << "\n\n";
  std::cout << "[*] turn    :" << turn << std::endl; // Debug
	std::cout << "[*] turns   :" << end_turn   << std::endl; // print turns
	std::cout << "[*] height  :" << height << std::endl; // print height
	std::cout << "[*] width   :" << width  << std::endl; // print width
	std::cout << "[*] myTeamID:"  << myID  << std::endl; // print myTeamID
	std::cout << "[*] enTeamID:"  << enID  << std::endl; // print enemyTeamID
	std::cout << std::endl;

	// print myagent array
	std::cout << "[*] myagent_array:" << std::endl;
	for(value item : myagents){
		agentid = (int)item.get<object>()["agentID"].get<double>();
		x       = (int)item.get<object>()["x"].get<double>();
		y       = (int)item.get<object>()["y"].get<double>();
		std::cout << "agentID:" << (int)item.get<object>()["agentID"].get<double>();
		std::cout << "  x:" << (int)item.get<object>()["x"].get<double>();
		std::cout << "  y:" << (int)item.get<object>()["y"].get<double>() << std::endl;
		agent_data[index_num][0] = x;
		agent_data[index_num][1] = y;
    // index (Debug) ------------------------
    agent_data[index_num][2] = agentid;
    index_num += 1;
		// agent数を求める
		agent_num += 1;
	}
	std::cout << std::endl;

	// print enagent array
	std::cout << "[*] enagent_array:" << std::endl;
	for(value item : enagents){
		agentid = (int)item.get<object>()["agentID"].get<double>();
		x       = (int)item.get<object>()["x"].get<double>();
		y       = (int)item.get<object>()["y"].get<double>();
		std::cout << "agentID:" << (int)item.get<object>()["agentID"].get<double>();
		std::cout << "  x:" << (int)item.get<object>()["x"].get<double>();
		std::cout << "  y:" << (int)item.get<object>()["y"].get<double>() << std::endl;
		agent_data[index_num][0] = x;
		agent_data[index_num][1] = y;

    // index (Debug) ---------------------------
    agent_data[index_num][2] = agentid;
    index_num += 1;
	}


	//genRandMap(仮)
	std::vector<int> field_rand;
  std::vector<int> buf;
	int map_num = 0; //map用添字
	int buf_height, buf_width;
  int field_rand_sum = -1; // <- Debug

	buf_height=(this->height/2)+(this->height%2);
	buf_width=(this->width/2)+(this->width%2);

  while(field_rand_sum < 0){
    field_rand_sum = 0; // <- Debug
    for(int i=0; i < height; i++){
      for(int j=0; j < width; j++){
        buf.push_back((int)map[map_num]);

				map_num += 1;
      }
      field_rand.insert(field_rand.end(), buf.begin(), buf.end());
      buf.clear();
    }
    field_rand_sum = std::accumulate(field_rand.begin(),field_rand.end(),0);  // <- Debug
  }

  // showing field_sum pt ---------------------------------
  std::cout << "[*]field_sum:" << field_rand_sum << std::endl;

	int val=0;

	for(int i=0;i<this->height;i++){
		for(int j=0;j<this->width;j++){
			this->setPanelScore(j, i, field_rand.at(val));
			val++;
		}
	}

	std::cout << "agents:" << agent_num << std::endl;
	// Debug -----------------------------------------
  // TODO: 汎用的な実装にする(agentIDとATTR)
  // このままだと自チームが敵側の場合OUT
	agent_num *= 2;
	for(int s=0; s < agent_num; s++){
		if(s < agent_num/2){
			this->agents.emplace_back(agent_data[s][0]-1, agent_data[s][1]-1, MINE_ATTR, agent_data[s][2]);
		}
		else{
			this->agents.emplace_back(agent_data[s][0]-1, agent_data[s][1]-1, ENEMY_ATTR, agent_data[s][2]);
		}
	}
	

	//ターン
	this->turn = 0;
	
	// 終了ターン
	this->max_turn = (int)matches.get<object>()["turns"].get<double>();
	std::cout << "max_turn:" << this->max_turn << std::endl;
	
	//シード値設定
	this->random = XorOshiro128p(time(NULL));
	
	this->canmoveAgents = std::vector<bool>(this->agents.size(), true);
	
	// エージェントの初期位置のパネルの属性を設定
	for(auto &i: this->agents) {
		setPanelAttr(i.getX(), i.getY(), i.getAttr());
	}

	//とりあえずSTOPにセット
	std::for_each(this->agents.begin(), this->agents.end(), [&, this](auto& a){
			a.move(STOP);
		});

}

bool Field::is_inside_closed(const std::pair<uint_fast32_t, uint_fast32_t>& coord) const{
	int_fast32_t totalscore = 0, score, x, y;
	bool check, flag;
	
	std::unordered_map<int_fast32_t, std::vector<int_fast32_t>> pureTerritory;
	pureTerritory = makePureTerritory(makePureTreeMine());
	
	for(const auto &[key, vec]: pureTerritory) {
		check = true;
		score = 0;
		for(auto pn: vec) {
			if(!checkLocalArea(indexX(pn), indexY(pn), MINE_ATTR)) {
				check = false;
				break;
			}
			x = this->indexX(pn);
			y = this->indexY(pn);
			if(x == coord.first && y == coord.second)
				flag = true;
		}
		if(check == true || flag == true)
			return true;
	}
	return false;
}

void Field::setPanels(const std::vector<std::vector<std::pair<uint_fast32_t, uint_fast32_t>>>& decided_route, const uint_fast32_t attr, const uint_fast32_t depth) const{
	std::for_each(decided_route.begin(), decided_route.end(),[&, this](auto& route){
			for(size_t i = 0; i < depth; i++){
				if(i >= route.size())
					break;
				this->setPanelAttr(route.at(i).first, route.at(i).second, attr);
			}
		});
}

void Field::update(){
  // agetn情報
	int agent_data[30][3];
  
  int index_num = 0;     // ↑添字
	int agentid, x, y;
	int agent_num = 0;

  int my_attr_tmp; // TeamID用のjson添字
  int en_attr_tmp;

	//double buffer;
	value maps;
	{
		std::fstream stream("./../../public_field/fields.json");
		if(!stream.is_open()) return 1;
		stream >> maps;
		assert(get_last_error().empty());
		stream.close();
	}

  value matches;
  {
    std::fstream stream("./../../matches.json");
    if(!stream.is_open()) return 1;
    stream >> matches;
    assert(get_last_error().empty());
    stream.close();
  }

	value::array agents = maps.get<object>()["teams"].get<value::array>(); // all agent

	// teamID  <- 別のスクリプトで取ってくる必要あり
	int myID = (int)agents[0].get<object>()["teamID"].get<double>();
	int enID = (int)agents[1].get<object>()["teamID"].get<double>();
  // これ
  int myTeamID = (int)matches.get<object>()["teamID"].get<double>();

  if (myTeamID == myID){
    my_attr_tmp = 0;
    en_attr_tmp = 1;
  }else{
    my_attr_tmp = 1;
    en_attr_tmp = 0;
  }

// agent array
	
	value::array myagents = agents[my_attr_tmp].get<object>()["agents"].get<value::array>(); // my
	value::array enagents = agents[en_attr_tmp].get<object>()["agents"].get<value::array>(); // enemy


  // Debug myTeamID -------------------------------------------------
  std::cout << "[*] myTeamID:" << myTeamID << std::endl;


	// Debug---------------
	std::cout << "\n\n";
  std::cout << "[*] turn    :" << turn << std::endl; // Debug
	//std::cout << "[*] turns   :" << end_turn   << std::endl; // print turns
	std::cout << "[*] height  :" << height << std::endl; // print height
	std::cout << "[*] width   :" << width  << std::endl; // print width
	std::cout << "[*] myTeamID:"  << myID  << std::endl; // print myTeamID
	std::cout << "[*] enTeamID:"  << enID  << std::endl; // print enemyTeamID
	std::cout << std::endl;

	// print myagent array
	std::cout << "[*] myagent_array:" << std::endl;
	for(value item : myagents){
		agentid = (int)item.get<object>()["agentID"].get<double>();
		x       = (int)item.get<object>()["x"].get<double>();
		y       = (int)item.get<object>()["y"].get<double>();
		std::cout << "agentID:" << (int)item.get<object>()["agentID"].get<double>();
		std::cout << "  x:" << (int)item.get<object>()["x"].get<double>();
		std::cout << "  y:" << (int)item.get<object>()["y"].get<double>() << std::endl;
		agent_data[index_num][0] = x;
		agent_data[index_num][1] = y;
    // index (Debug) ------------------------
    agent_data[index_num][2] = agentid;
    index_num += 1;
		// agent数を求める
		agent_num += 1;
	}
	std::cout << std::endl;

	// print enagent array
	std::cout << "[*] enagent_array:" << std::endl;
	for(value item : enagents){
		agentid = (int)item.get<object>()["agentID"].get<double>();
		x       = (int)item.get<object>()["x"].get<double>();
		y       = (int)item.get<object>()["y"].get<double>();
		std::cout << "agentID:" << (int)item.get<object>()["agentID"].get<double>();
		std::cout << "  x:" << (int)item.get<object>()["x"].get<double>();
		std::cout << "  y:" << (int)item.get<object>()["y"].get<double>() << std::endl;
		agent_data[index_num][0] = x;
		agent_data[index_num][1] = y;

    // index (Debug) ---------------------------
    agent_data[index_num][2] = agentid;
    index_num += 1;
	}

	// Debug -----------------------------------------
  // TODO: 汎用的な実装にする(agentIDとATTR)
  // このままだと自チームが敵側の場合OUT
	agent_num *= 2;
  std::vector<Agent>().swap(this->agents);
	for(int s=0; s < agent_num; s++){
		if(s < agent_num/2){
			this->agents.emplace_back(agent_data[s][0]-1, agent_data[s][1]-1, MINE_ATTR, agent_data[s][2]);
		}
		else{
			this->agents.emplace_back(agent_data[s][0]-1, agent_data[s][1]-1, ENEMY_ATTR, agent_data[s][2]);
		}
	}

}

/src/useful.cpp
#include "useful.hpp"

UF::UF(uint_fast32_t size) {
	data = std::vector<int_fast32_t>(size);
	rank = std::vector<int_fast32_t>(size);
	for(size_t i = 0; i < size; i++) {
		data[i] = i;
		rank[i] = 0;
	}
}

int_fast32_t direction2x(Direction direction) {
	switch(direction) {
		case UP:
		case DOWN:
			return 0;
		case RUP:
		case RIGHT:
		case RDOWN:
			return 1;
		case LDOWN:
		case LEFT:
		case LUP:
			return -1;
  	case STOP:
	  	return 0;									
	}
	return 0;
}

int_fast32_t direction2y(Direction direction) {
	switch(direction) {
		case UP:
		case RUP:
		case LUP:
			return -1;
		case RIGHT:
		case LEFT:
			return 0;
		case RDOWN:
		case DOWN:
		case LDOWN:
			return 1;
  	case STOP:
	  	return 0;
	}
	return 0;
}

Direction xyToDirection(int_fast32_t dx, int_fast32_t dy) {
	int x = (dx + (7 * dy + 7) / (3 * dx + 4) + 8) % 8;
	int y = 4 - dx;
	int dir = (((dy + 1) / 2 + 1) % 2) * x + (dy + 1) / 2 * y;
	return (Direction)dir;
}

XorOshiro128p::XorOshiro128p() {
}

XorOshiro128p::XorOshiro128p(uint_fast64_t seed) {
	if(seed == 0) seed = time(NULL);

	this->seed[0] = splitmix64(seed);
	this->seed[1] = splitmix64(this->seed[0]);
}

/src/main.cpp
#include <iostream>
#include <fstream>
#include <string>
#include <stdlib.h>
#include "field.hpp"
#include "useful.hpp"
#include "disp.hpp"

using namespace picojson;

//Field field(16, 16);
Field field;

Greedy greedy;
BeamSearch beam_search;
Astar astar;

void move2json();
std::string getType(int nx, int ny, int dx, int dy);

int main(int argc, char *argv[]) {
	field.init();

	DisplayWrapper* framework = new Display();
	framework->setField(&field);
	framework->setInstance(framework);
	framework->start(argc, argv);
	delete framework;

	return 0;	
}

/*
int main(int argc, char *argv[]){
	field.init();
	astar.init(&field);
	while(true){
		beam_search.move(&field, MINE_ATTR);
		//astar.move(&field, MINE_ATTR);
		//greedy.move(&field, MINE_ATTR);
		greedy.move(&field, ENEMY_ATTR);
		field.applyNextAgents();
		field.print();
		if(field.checkEnd()){
			field.judgeWinner();
			break;
		}
	}
	return 0;
}
*/


/*
static double_t move_weight;
static double_t state_weight;
static double_t heuristic_weight;
static double_t value_weight;
static double_t is_on_decided_route_weight;
static double_t is_on_mine_panel_weight;
static double greedy_count;
static double occpancy_weight;
static double is_on_decided_weight;
static uint_fast32_t max_mine_distance;
static uint_fast32_t min_mine_distance;
static uint_fast32_t min_agent_distance;
static uint_fast32_t min_goal_distance;
static uint_fast32_t max_move_cost;
static uint_fast32_t min_value;
static uint_fast32_t min_move_cost;
static uint_fast32_t search_count;
*/

/*
int main(int argc, double_t argv[]){
	if(argc < 18){
		printf("\nparameters error\n");
		return 0;
	}
	//---------------- Node ----------------
	//double
	move_weight                = argv[1];
	state_weight               = argv[2];
	heuristic_weight           = argv[3];
	value_weight               = argv[4];
	is_on_decided_route_weight = argv[5];
	is_on_mine_panel_weight    = argv[6];
	//---------------- Goal ----------------
	//double
	greedy_count               = argv[7];
	occpancy_weight            = argv[8];
	is_on_decided_weight       = argv[9];
	//---------------- Branching ----------------
	//uint_fast32_t
	max_mine_distance          = argv[10];
	min_mine_distance          = argv[11];
	min_agent_distance         = argv[12];
	min_goal_distance          = argv[13];
	max_move_cost              = argv[14];
	min_value                  = argv[15];
	min_move_cost              = argv[16];
	search_count               = argv[17];
	
	astar.init(&field);
	while(true){
		//astar.move(&field, MINE_ATTR);
		//astar.move(&field, ENEMY_ATTR);
		
		//beam_search.move(&field, MINE_ATTR);
		//beam_search.move(&field, ENEMY_ATTR);
		
		greedy.move(&field, MINE_ATTR);
		greedy.move(&field, ENEMY_ATTR);
		field.applyNextAgents();
		field.print();
		if(field.checkEnd()){
			field.judgeWinner();
			break;
		}
	}
	return 0;
}
*/

/*
int main(int argc, char *argv[]) {
	astar.init(&field);
	field.init();

	while(true){
		
		//astar.move(&field, MINE_ATTR);
		greedy.move(&field, MINE_ATTR);
		greedy.move(&field, ENEMY_ATTR);
		
		// Debug ---------------------------------------
		move2json();

    // Debug ---------------------
    char *command = "python ../../test.py";
    int req;

    req = system(command);

    // ----------------------------

		field.applyNextAgents();

		field.print();

		if(field.checkEnd()){
			field.judgeWinner();
			//move2json();
			//std::this_thread::sleep_for(std::chrono::minutes(1));
			break;
		}
	}
	
	
	
	return 0;
}
*/

void move2json(){
    object actions;

    array datalist;
    //int turn = Field.init().agent_num;	
    double j;
    double ID;

    double dx,dy; // 移動先
    double nx,ny;
    double x, y;  // 移動前

    std::string type;

    //std::cout << field.agents.size() << std::endl;

    // forで毎回id,dx,dyのデータを取ってくる必要あり
    for(int i = 0; i < field.agents.size()/2; i++){
    	{


        	object id;
          ID= (double)field.agents.at(i).getID();    // agentID
      		//j = (double)i+1;  // agentID
          x = (double)field.agents.at(i).getX();     // 移動前 x
          y = (double)field.agents.at(i).getY();     // 移動前 y
          nx= (double)field.agents.at(i).getnextX(); // 移動先 x
          ny= (double)field.agents.at(i).getnextY(); // 移動先 y

          dx = nx - x; // xの差をとる
          dy = ny - y; // yの差をとる
          
          std::cout << "x:" << dx << " " << "y:" << dy << std::endl;

        	//id.insert(std::make_pair("data", value(data)));
          
          // Debug
          type = getType((int)nx, (int)ny , (int)dx, (int)dy);

		      id.insert(std::make_pair("agentID", value(ID)));
		      id.insert(std::make_pair("dx", value(dx)));
		      id.insert(std::make_pair("dy", value(dy)));
		      id.insert(std::make_pair("type", value(type)));

		
        	datalist.push_back(value(id));
		

    	}
	
    }	


    // データまとめ   
    actions.insert(std::make_pair("actions", value(datalist)));

    // データ表示
    std::cout << value(actions) << std::endl;
    // データ書き込み
    std::ofstream outputfile("../../action.json");

    outputfile << value(actions);

    outputfile.close();
}

std::string getType(int nx, int ny, int dx, int dy){
    uint_fast32_t attr;
    if((dx == 0) && (dy == 0)){
      return "stay";
    }else{
      attr = field.at(nx,ny)->getAttr();
      if(attr == ENEMY_ATTR)
        return "remove";
      else
        return "move";
    }
}

/params/optimize.cpp
/*
 * 交叉法の条件
 * 一つの群生の数を Np = swarm.size()
 * 一つの個体の遺伝子長 Dim = individual.params.size()
 *
 * BLX-alpha + elite: Np >= 2
 *
 * SPX + elite: Np = n * (Dim + 1) + 1, nは任意の自然数
 * 正の数が保証されないので良くないかもしれない
 *
 */
#include <cstdio>
#include <vector>
#include <cstring>
#include <cmath>
#include <chrono>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <err.h>
#include <errno.h>
#include "useful.hpp"

size_t Dim = 10;
size_t Np = 14;
size_t Ng = 150;

// 交叉法
#define CHIASMA_BLXa
// #define CHIASMA_SPX

// メインプログラムでの評価を行うときの試行回数
size_t numberOfTrials = 8;

class Swarm;
class Individual {
friend Swarm;
private:
	XorOshiro128p rand;
	double rate;
	std::vector<double> params;
	
	Individual(std::vector<double> parameters): rate(0.0) {
		std::random_device seed;
		rand = XorOshiro128p(seed());
		params = parameters;
	}

	Individual *makeNewIndividual_BLXa(const Individual *p) {
		std::vector<double> genParam(Dim);
		double dist, max, min;
		for(size_t i = 0; i < Dim; i++) {
			dist = std::abs(p->params[i] - params[i]);
			max = std::max(p->params[i], params[i]) + 0.3 * dist;
			min = std::min(p->params[i], params[i]) - 0.3 * dist;
			dist = std::abs(max - min);
			genParam[i] = min + rand.gend(dist);
		}
		Individual *indiv = new Individual(genParam);
		return indiv;
	}

	void makeNewIndividual_SPX(std::vector<Individual *> &p, std::vector<Individual *> &res, size_t base) {
		if(p.size() % Dim != 0) {
			fprintf(stderr, "交叉に使用する個体の数が不正です。(SPX)\n");
			exit(EXIT_FAILURE);
		}

		// Center of gravity
		std::vector<double> g(Dim);
		for(size_t i = 0; i < Dim; i++) {
			for(size_t j = 0; j < Dim; j++) {
				g[j] += p.at(i)->params[j];
			}
		}
		for(size_t j = 0; j < Dim; j++) {
			g[j] += params[j];
			g[j] /= Dim + 1;
		}

		// (Si)	
		double eps = std::sqrt(Dim + 2);
		std::vector<std::vector<double>> S(Dim + 1, std::vector<double>(Dim));
		for(size_t j = 0; j < Dim; j++) S[0][j] = g[j] + eps * (params[j] - g[j]);
		for(size_t i = 1; i < Dim; i++) {
			for(size_t j = 0; j < Dim; j++) {
				S[i][j] = g[j] + eps * (p.at(i - 1)->params[j] - g[j]);
			}
		}

		// (ri)
		std::vector<double> r(Dim);
		for(size_t i = 0; i < Dim; i++) r[i] = std::pow(rand.gend(), 1.0 / (double)(i + 1));

		// (Ci)
		std::vector<std::vector<double>> C(Dim + 1, std::vector<double>(Dim));
		C[0] = S[0];
		res.at(base) = new Individual(C[0]);
		for(size_t i = 1; i < Dim + 1; i++) {
			for(size_t j = 0; j < Dim; j++) {
				C[i][j] = S[i][j] + r[i - 1] * (S[i - 1][j] - S[i][j] + C[i - 1][j]);
			}
			res.at(base + i) = new Individual(C[i]);
		}
	}

public:
	Individual(): rate(0.0) {
		std::random_device seed;
		rand = XorOshiro128p(seed());
		for(size_t i = 0; i < Dim; i++) params.emplace_back(rand.gend());
	}

	void eval() {
		rate = 0.0;

		for(size_t i = 0; i < numberOfTrials; i++) {
			int fd[2];
			char buf[100];
			memset(buf, 0, sizeof(buf));	// buf clear.

			if(pipe(fd) < 0) {
				perror("PIPE ERROR");
				exit(EXIT_FAILURE);
			}

			pid_t pid = fork();
			switch(pid) {
			case -1:
				// fork error.
				err(EXIT_FAILURE, "Could not fork.");
				break;
			case 0: {
				// child process.
				dup2(fd[0], 0);
				dup2(fd[1], 1);
				close(fd[0]);
				close(fd[1]);
				char *const args[] = {"./run", NULL};
				execv(args[0], args);
				break;
					}
			default:
				// parents
				int childStatus;
				printf("This is parent process. child process number is %d\n", pid);

				pid_t wait_pid = wait(&childStatus);
				
				read(fd[0], buf, sizeof(buf));

				// 勝率での評価
				/*	
				if(buf[0] == 'W') {
					printf("Win Mine\n");
					rate += 3.0;
				} else if(buf[0] == 'L') {
					printf("Lose Mine\n");
					rate += 1.0;
				} else {
					printf("Draw\n");
					rate += 2.0;
				}
				*/

				// 得点差による評価
				int scoreDiff = std::atoi(buf);
				printf("スコア差: %d\n", scoreDiff);
				rate += scoreDiff;

				close(fd[0]);
				close(fd[1]);
				if(WIFEXITED(childStatus)) {
					printf("Finished uccessfully. child = %d, status = %d\n", wait_pid, WEXITSTATUS(childStatus));
				} else if(WIFSIGNALED(childStatus)) {
					printf("Child process %d ended by signale %d\n", wait_pid, WTERMSIG(childStatus));
				} else {
					err(EXIT_FAILURE, "wait err");
					exit(EXIT_FAILURE);
				}
			}
		}
		rate /= numberOfTrials;
	}

	void print() const {
		fprintf(stderr, "params = ");
		for(const auto i: params) fprintf(stderr, "%lf ", i);
		fprintf(stderr, "\n");
		fprintf(stderr, "rate = %lf\n", rate);
	}

	inline double getRate() {
		return rate;
	}
};

class Swarm {
private:
	std::vector<Individual *> swarm;
	XorOshiro128p rand;
	double cumulativeSum;

	Swarm(std::vector<Individual *> swarm): swarm(swarm), cumulativeSum(0) {
		std::random_device seed;
		rand = XorOshiro128p(seed());
	}

	void shuffleSwarm() {
		for(size_t i = 0; i < swarm.size(); i++) {
			size_t j = rand(swarm.size() - 1);
			Individual *work = swarm[i];
			swarm[i] = swarm[j];
			swarm[j] = work;
		}
	}

	void samplingWithoutReplacement(size_t num, std::vector<Individual *> &res) {
		res = std::vector<Individual *>(num);
		double cumulativeSumBuf = cumulativeSum;
		for(size_t i = 0; i < num; i++) {
			size_t pos = rand.gend(cumulativeSumBuf);
			size_t j = 0;
			double rateSum = 0;
			while(rateSum <= pos && i +  j < swarm.size()) {
				rateSum += swarm[i + j++]->rate;
			}
			res[i] = swarm[i + j - 1];
			cumulativeSumBuf -= swarm[i + j - 1]->rate;
			std::swap(swarm[i], swarm[i + j - 1]);
		}
	}

public:
	Swarm(size_t size): cumulativeSum(0) {
		swarm = std::vector<Individual *>(size, nullptr);
		for(size_t i = 0; i < size; i++) swarm[i] = new Individual();

		std::random_device seed;
		rand = XorOshiro128p(seed());
	}
	
	Swarm() {
	}

	~Swarm() {
		for(size_t i = 0; i < swarm.size(); i++) delete swarm[i];
	}

	void eval() {
		cumulativeSum = 0;
		for(auto i: swarm) {
			i->eval();
			cumulativeSum += i->rate;
		}
	}

	Individual *getElite() {
		Individual *elite;
		double ratebuf = -1.0;
		for(auto i: swarm) {
			if(i->rate > ratebuf) {
				ratebuf = i->rate;
				elite = i;
			}
		}
		return elite;
	}

	Swarm *makeNextSwarm() {
		std::vector<Individual *> nextSwarm(swarm.size(), nullptr);
		eval();
		shuffleSwarm();
		fprintf(stderr, "------ Swarm --------------------------\n");
		for(const auto i: swarm) {
			i->print();
			fprintf(stderr, "addr = %p\n", i);
		}

		// ルーレット
		for(size_t i = 0; i < nextSwarm.size() - 1; i++) {
			std::vector<Individual *> p;

#ifdef CHIASMA_BLXa
			// BLX-alpha 法	
			samplingWithoutReplacement(2, p);
			nextSwarm[i] = p[0]->makeNewIndividual_BLXa(p[1]);	
#endif

#ifdef CHIASMA_SPX
			// SPX 法
			samplingWithoutReplacement(Dim + 1, p);
			Individual *pp = p[Dim];
			p.pop_back();
			pp->makeNewIndividual_SPX(p, nextSwarm, i);
			i += Dim;
#endif
		}
		
		// エリート
		nextSwarm[nextSwarm.size() - 1] = new Individual(getElite()->params);

		return new Swarm(nextSwarm);
	}

	void print() {
		for(const auto i: swarm) i->print();
	}
};

int main() {
	std::chrono::system_clock::time_point start, end;
	/*
	start = std::chrono::system_clock::now();
	end = std::chrono::system_clock::now();
	double time = (double)(std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.0);
	printf("time: %lf\n", time);
	*/

	Swarm *swarm, *nextSwarm;

	swarm = new Swarm(Np);

	for(size_t i = 0; i <= Ng; i++) {	
		fprintf(stderr, "----------------------------------------\n");
		fprintf(stderr, "%ld世代目!!\n", i);

		if(i == Ng) {
			fprintf(stderr, "------ Final --------------------------\n");
		}

		nextSwarm = swarm->makeNextSwarm();

		printf("%ld %lf\n", i, swarm->getElite()->getRate());
		delete swarm;
		swarm = nextSwarm;
	}
}

